<!DOCTYPE html>
<html>
  <head>
    <title>Vivado Advanced Tcl Scripting</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <!-- when changing the stylesheet file please see also remark below -->
    <link rel="stylesheet" type="text/css" href="styling.css" />
  </head>
  <body>
<!-- :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: -->
<!-- :::::::::: template pages come first ... skip to REALCONTENT ::::::::: -->
<!-- :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: -->
<textarea id="source">

layout: true
name: blank
styling: styling.css
styling-by: Martin Weitzel

<!--
  *****************************************************************************
  Template used for title page (only)
  *****************************************************************************
  Please change the 'styling-by:' attribute if you change the style-sheet.
-->

.stylehint[
Styled with [{{styling}}]({{styling}}) by {{styling-by}}
]

---
layout: true
name: plain
copyright: (CC) BY-SA
branding:  [Dipl.-Ing. Martin Weitzel](http://tbfe.de) &#8199;&#8199; 2017-04-19 … 2017-04-21
customer:  [PLC2 – Programmable Logic Competence Center](http://plc2.com)

<!--
  *****************************************************************************
  Template used for for pages NOT referring to any Info-Graphic
  *****************************************************************************
  The following attributes are mandatory FOR THE TEMPLATE PAGE and should
  simply be left empty if not meaningful.

  copyright: will be reproduced in each page footer first
  branding: will reproduced in each page footer next
  customer: will be reproduced in each page footer last

  As the above attributes are part of several page templates a global replace
  should be used for consistent changes.

  On pages USING THIS TEMPLATE the following attributes must be set:

  header: ## and header text (i.e. including the markdown formatting indicator)

-->

{{header}}

.pagefooter[
{{copyright}}: {{branding}} .plc2-logo[{{customer}}]
]

---
layout: true
name: linkinfo
copyright: (CC) BY-SA
branding:  [Dipl.-Ing. Martin Weitzel](http://tbfe.de) &#8199;&#8199; 2017-04-19 … 2017-04-21
customer:  [PLC2 – Programmable Logic Competence Center](http://plc2.com)

<!--
  *****************************************************************************
  Template used for for pages INTRODUCING to a new Info-Graphic
  *****************************************************************************
  On this kind of pages a size-reduced version of the whole info graphic will
  be reproduced and occupies approximately 2/3 of the page width. So only add
  little information, preferably links to later pages dealing with single
  sections of the info graphic.

  On pages USING THIS TEMPLATE the following attributes must be set:

  graphic: file path to of the infographic EXCLUDING the suffix.
  header: ## and header text (i.e. including the markdown formatting indicator)

-->

{{header}}

.infographic[
[![Info-Grafik](InfoGraphics/{{graphic}}.png)](InfoGraphics/{{graphic}}.png
                "Click to open – add [CTRL+] SHIFT for new [tabbed] window")
]

.pagefooter[
{{copyright}}: {{branding}} {{customer}} .plc2-logo[]
]

---
layout: false
template: blank
name: frontmatter

.title[
	Advanced Vivado-Scripting._[]
]

.subtitle[
	Controlling the Vivado Design Tool with Tcl-Scripts  
]
.author.pull-left[
	Durchführung  
	Dipl.-Ing. Martin Weitzel  
	Technische Beratung für EDV  
	http://tbfe.de  

]
.client.pull-right[
	Open Training and Workshop  
	2017-04-19 to 2017-04-21  
	Programming Logic Competence Center  
	http://plc2.com
]

.F[:
You may download this presentation from the
[Author's Internet Site](http://tbfe.de/archive)
for any use in compliance with the
[Creative Commons BY-SA License](http://creativecommons.org/licenses/by-sa/2.0/).
As it has been created using the free HTML4-Tool [Remark](http://remarkjs.com),
its content is written using the
[Markdown-Syntax](http://daringfireball.net/projects/markdown/syntax),
so you may even enhance the purely electronic (non-printed) form with your own
annotations, only by means of any ordinary text editor. Just hit the P-key while
viewing this in an internet browser, and follow instructions.
]

???

(use +/- above to adjust the font size for convenient reading)

Remark allows to add presenter notes to each page. As that feature is **not**
used by the author of that presentation, it is available for private annotations
from [this page](#content) on.

Assuming you have downloaded and stored this presentation as HTML-file, proceed
as follows:

* Open the file in a text editor of your choice.

* Locate the page which you want to annotate.

  * You may do so by just scrolling down (but often it is easier to)
  * use the text search feature of your editor.

* Locate the separator to the next page (i.e. `---` in a line of its own).

* Before that add another line with three question marks (`???`) only.

Between these to separator lines you can put your annotations and view these
by using as you just view this page.

**Hint:**
Indent code examples with four spaces at the beginning of each line and they
will be displayed with their original line breaks. As an example, below the
page structure including annotations is shown:

    template: plain
    name: used_for_internal_links
    header: ## Shown at the Top of the Page

    Simply scroll down through this document loaded in an editor and you will
    probably catch the basics of Markdown-Syntax easily, e.g.  how to put in
    *slight* or **strong** emphasis or [add a link](http://tbfe.de/downloads).

    ???
    From here follow the [Presenter Notes], i.e. your private annotations
    ...
    ...

    [Presenter Notes]: adding-longer-links-that-keeps-text--uncluttered

    ...
    up to here.
    ---

To return to the normal view, now press the P-key once more.

<!--
If you want to put in meta-annotations, i.e. text that is not even shown
after pressing the P-key, simply use HTML comments, like it is done here.
-->

---
template: plain
class: agenda
name: content
header: ## Agenda

------------------------------------------------------------------------------

* 2017-04-19

    * Part 1: [Tcl Quick Refresher](#tcl_quick_refresher)

    * Part 2: [Retrieving Scripts from Journals](#retrieving_scripts_from_journals)


* 2017-04-20 

    * Part 3: [Tcl Vivado Integration](#tcl_vivado_integration)

    * Part 4: [Processing Files and Reports](#processing_files_and_reports)

* 2017-04-21

    * Part 5: [Automating Systematic Variations](#automating_variations)

    * Part 6: [Tcl from the Reusablity Viewpoint](#tcl_reusability)

------------------------------------------------------------------------------

---
template: plain
name: tcl_quick_refresher
header: ## Part 1: Tcl Quick Refresher

------------------------------------------------------------------------------

* [Tcl Quick Syntax Refresher](#tcl_quick_syntax)

    * [Command and Word Separation](#tcl_command_and_word_sep)
    * [Three Kinds of Quoting](#tcl_three_kinds_of_quoting)
    * [Variable and Command Substitution](#tcl_variable_and_command_subst)
    * [Basic Flow Control](#tcl_basic_flow_control)
    * [List Handling](#tcl_list_handling)
    * [Arithmetic Expressions](#tcl_math_operations)

------------------------------------------------------------------------------

* [Tcl Quick Library Refresher](#tcl_quick_library)

    * [Character Strings](#tcl_character_strings)
    * [Regular Expressions](#tcl_regular_expressions)
    * [File Handling](#tcl_file_handling)
    * [Date & Time](#tcl_date_and_time)

------------------------------------------------------------------------------

---
template: linkinfo
graphic: VivadoVsTclSyntax
name: tcl_quick_syntax
header: ### Tcl Quick Syntax Refresher

* Tcl syntax very simple

* Flexibility comes from

   * using variables and

   * command return values

* Anything else is inside the commands, i.e.

   * uniformity comes from conventions

   * *Tcl Style* and *Vivado Style* slightly differs

---
template: plain
name: tcl_command_and_word_sep
header: #### Command and Word Separation

The first step._[] of *Tcl Syntax Analysis* is locating

* Command Separators:

    * Un-masked Line-Endings

    * Semicolons

* Word Separators:

    * Sequences of *White-Space*

.N[
Command and Word Separation may be protected by any of Tcl's mechanisms
for Quoting.
]

* [Quick-Tcl → Line Concatenation](quick-tcl.html#line_concatenation)
* [Quick-Tcl → Command Separation](quick-tcl.html#command_separation)
* [Quick-Tcl → Word Separation](quick-tcl.html#word_separation)

.F[:
Technically detecting masked line-endings, though it appears to be a kind of
quoting, is a step that occurs separately before Tcl looks for command an
word separators.  A line-ending is masked with a back-slash (`\`), removing
it completely together with any leading white-space of the next line (which
may or may not have another masked line-ending itself).
]

---
template: plain
name: tcl_variable_and_command_subst
header: #### Variable and Command Substitution

The Tcl syntax looks up

* `$`-signs followed by a valid variable name  
  – for substitution by the variable content

* parts of a command line enclosed in `[` … `]`  
  – for substitution by the return value of the enclosed command (…)

.N[
In Vivado Tcl's syntax analysis is modified so that command substitution does
**not** take place when the square brackets contain a single integral number,
two integral numbers separated by a colon, or an asterisk.
]

* [Quick-Tcl → Command Separation](quick-tcl.html#variables_quickly)
* [Quick-Tcl → Word Separation](quick-tcl.html#using_command_substitution)

---
template: plain
name: tcl_three_kinds_of_quoting
header: #### Three Kinds of Quoting

Tcl Syntax elements triggering special mechanisms can be disabled by
*Quoting* which comes in three forms:._[]

* *Backslash-Quoting* (`\`…) – disable special interpretation of the
  character following next

* *Partial Quoting* (`"` … `"`) – disable word/command separators  
  (backslash quoting still works, full quoting is disabled too)

* *Full Quoting* (`{` … `}`) – disable every special meaning, only …
    * … **match** the closing brace by counting contained braces  
      (opening = +1, closing = -1, closing for counter zero is match)
    * … **disable** counting for braces preceded with a backslash

.N.center[
Mastering the "Tcl-Syntax" to a large degree is to master quoting.
]

* [Quick-Tcl → Quoting with Backslashes](quick-tcl.html#backslash_quoting)
* [Quick-Tcl → Quoting with Double Quotes](quick-tcl.html#doublequote_quoting)
* [Quick-Tcl → Quoting with Curly Braces](quick-tcl.html#curlybrace_quoting)

.F[:
By use of a backslash also certain non-graphic character my be specified,
much like in C/C++.
]

---
template: plain
name: tcl_basic_flow_control
header: #### Basic Flow Control

Flow Control in Tcl is actually implemented via commands:

* It might appear to be part of the syntax – **but is not**

* Instead there is an ordinary parsing of the command line …

    * … which might turn out to call a flow control command

    * … that *internally* implements the required behaviour

.N[
This may not be obvious at first glance, even not at second or third …._[]
]

.F[:
One of the reasons is the use of curly braces as nestable quoting mechanism.
This makes flow control in Tcl look much like (inseparable) blocks of code
in C/C++, though in that case braces are a **syntactical** mechanism.  
In other words: Considering its syntax (only), Tcl knows **a lot less**
– actually close to nothing – about control flow in a program
in comparison to most
any other programming language.
On the other hand this allows to introduce
new ways of flow control simply by defining another command with the desired
behaviour.
]

* [Quick Tcl → Flow Control](quick-tcl.html#flow_control)
* [Quick Tcl → Subroutines](quick-tcl.html#subroutines)

---
template: plain
name: tcl_list_handling
header: #### List Handling

Some commands central to Vivado return there result as lists

* Familiarity with Tcl's list handling is crucial for Vivado scripting too

* Compared to (native) Tcl lists in Vivado are slightly extended

* It may pay to get some experience with lists **outside** Vivado first

.N[
Vivado extensions to Tcl lists have little effect on most any of Tcl's
list handling commands, except when new elements are added to a list.._[]
]

* [Quick Tcl → Lists 101 – The Basics](quick-tcl.html#the_basics)
* [Quick Tcl → Lists 101 – Nested Lists](quick-tcl.html#nested_lists)
* [Quick Tcl → Lists 101 – Constructing Lists](quick-tcl.html#constructing_lists)
* [Quick Tcl → Lists 101 – Extending (and Shorting) Lists](quick-tcl.html#extending_lists)

.F[:
**That is the difference:** In Tcl data is not really "typed". Especially
everything that can be put as element into a list has a representation as
string. Therefore a (native Tcl) list can be "heterogeneous" with respect
to the contained elements. Contrary, in Vivado, when a lists contains
elements that represent specific elements of the *Internal Design Model*,
it must be homogeneous. Accessing a single list element keeps it type
(as some object of the in memory design model), **but using it in a string
context strips away anything and keeps (as string value) just the *name*
property.
]

---
template: plain
name: tcl_math_operations
header: #### Mathematical Operations

As a major difference to other high-level programming languages the
Tcl Syntax does **not** know about

* Basic arithmetic, logic, and relational expressions

    * plus, minus, multiplies, …
    * equals/unequals, less, less-or-equal, …
    * negate, and, or, shift

* Mathematical Functions

    * classic trigonometric and their inverses
    * powers and logarithms, …

.N.center[
All this operations are carried out (only) by the command `expr`.
]

* [Quick Tcl → Evaluating Arithmetic Expressions](quick-tcl.html#cmd_expr)

---
template: plain
name: tcl_recursive_syntax
header: #### Recursive Syntax

The individual steps of Tcl syntax analysis happen in a given order
which sometimes – but rarely – is not adequate for the problem at hand.

* E.g. spaces as content of a variable are not word separators …

* … because such are looked up **prior** to variable substitution

.N[
The command `eval` helps out here by starting another run through
syntax analysis on its concatenated arguments after the first – the
one that turned out the command to execute is `eval`.
]

* [Quick Tcl → Evaluating Any String As Command](quick-tcl.html#cmd_eval)

---
template: plain
name: tcl_quick_library
header: ### Tcl Quick Library Refresher

The most important *Tcl Library Functions* for Vivado scripting

* [String Handling](#tcl_character_strings)

* [File Handling](#tcl_file_handling)

* [Date & Time](#tcl_date_and_time)

.N[
Tasks in string processing belonging to the category of
*Analyzing and Parsing Content* are often easily solved via
[Regular Expressions](#tcl_regular_expressions).
]

---
template: plain
name: tcl_character_strings
header: #### Character Strings

Most any handling of character strings is done by sub-commands of
the Tcl command `string`:

* Comparisons

* Substring and single character access

* Character classification

* …

.N[
For concatenating two strings held in variables (or one string
from a variable with a fixed part) no special command is necessary.._[]
]

* [Quick Tcl → Handling Character Strings](quick-tcl.html#char_strings)

.F[:
Probably obvious is that … `$greet$name` … produces the concatenated
content of the variables `greet` and `name`.
Not quite obvious may be how a single letter could be appended to a
variable content, say for pluralisation. If `x` contains some word to
which a literal `s` must be appended, `$xs` clearly doesn't work. The
solution is to use `${x}s`.
]

---
template: plain
name: tcl_regular_expressions
header: #### Regular Expressions

Originating in the Unix tradition, Tcl **of course** supports REs._[] for:

* Flexible comparisons, e.g.  
  –  `regexp {[+-][0-9]+([.][0-9]*)?} $num`

* Parsing, e.g.  
  – `regexp {(\d{1,3}(?:\.\d{3})*),(\d{2}) Euro} $ec - eur cnt`

* Substitutions, e.g.  
  – `regsub {^[ \t]*(.*[^ \t])[ \t]*$) $line {\1} line`

.N.center[
Clearly, the above is does not strive to introduce REs from ground-up! :-)
]

* [Quick Tcl → Using Regular Expressions](quick-tcl.html#regular_expressions)

.F[:
Regular Expressions – or REs in short – are part of nearly any modern
programming language. They are rooted in Unix, which used REs since its
very beginning in the `ed` editor, from which later the command `grep`
was derived, as Unix users often started the editor to use the (single)
command `g/`*`re`*`/p` to search in a file for a line matching the pattern
*`re`*.
]

---
template: plain
name: tcl_file_handling
header: #### File Handling

File handling is part of Tcl in two forms:

* Handling files and directories as whole. with

   * most operations as `file` subcommands._[]

* Handling the **content** a files with a C-style API

   * `open` returns a "magic cookie" (called *channel*) …
   * … serving as handle for other commands (`read`, `puts` …) …
   * … which must finally be `close`-d

.N[
TCP/IP connections are handled in a much similar style but have to
be opened with the `socket` command.
]

* [Quick Tcl → File Handling](quick-tcl.html#file_handling)

.F[:
Because of tradition (and then backward compatibility) there are some few
more commands, like `pwd`, `cd`, and `glob`. These are also covered under
the *Quick Tcl* Link above.
]


---
template: plain
name: tcl_date_and_time
header: #### Date & Time

In the Unix tradition the Tcl's idea of time is kept as a count since
some epoch.

* Subcommands of `clock` support a rich variety of operations

* Older versions of Tcl counted in seconds from 1970-01-01 GMT

* Resolution now is increased, epoch can be easily determined with

    * `puts [clock format 0]`

.N[
Note that the above displays the epoch in **local time** according to
the time zone of the computer on which the command is executed.._[]
]

* [Quick Tcl → Date And Time](quick-tcl.html#date_and_time)

.F[:
Therefore in Germany the output will probably not be … `00:00:00` … but
… `01:00:00` … (as the time-point of the epoch). So you may want to add
`-timezone UTC` to the above.
]

---

template: plain
name: retrieving_scripts_from_journals
header: ## Retrieving Scripts from Journals

------------------------------------------------------------------------------
* [Accessing the Vivado Design Suite](#accessing_the_vivado_design_suite)

  * [Using the Vivado GUI](#using_the_vivado_gui)
  * [Using Vivado Tcl Commands](#using_vivado_tcl_commands)
------------------------------------------------------------------------------
* [Accessing the Tool Command Language](#accessing_the_tool_command_language)

  * [The Vivado Tcl-Console](#the_vivado_tcl_console)
  * [Suspending the Vivado GUI](#suspending_the_vivado_gui)
  * [Vivado Batch Script Mode](#vivado_batch_script_mode)
------------------------------------------------------------------------------
* [From Journal-Files to Automation](#from_journal_files_to_automation)

  * [Turning Journals into Tcl-Scripts](#turning_journals_into_tcl_scripts)
  * [Plain Use vs. Packaging in `proc`s](#plain_use_vs_packaging_in_procs)
------------------------------------------------------------------------------
* [Bring-in Your Own Design?](#bring_in_your_own_design)

---
template: linkinfo
graphic: Tcl_Vivado_Integration
name: accessing_the_vivado_design_suite
header: ## Accessing the Vivado Design Suite

There are two major ways to work with Vivado:

* [Via GUI](#using_the_vivado_gui)

* [Via Tcl Commands](#using_vivado_tcl_commands)

The GUI is usually brought up first when Vivado is started

* by clicking on its icon or
* by specifying the path to its executable on the command line.._[]

.F[:
At the command line the option `-mode tcl` or `-mode batch` may be used which
would not show the GUI immediately but only when requested.
]

---
template: plain
name: using_the_vivado_gui
header: ### Using the Vivado GUI

For many first-time users Vivado may appear to be a GUI based tool, accessed
in well-known ways:

* Present *State Information* in various "Graphical Views", which the user can
  open and close, resize and arrange on the screen.

* *Initiate Actions* by choosing from *Menus* or pressing *Buttons* provided
  in a Toolbars …

* … eventually prompting for action-specific details in *Pop-Up Dialogues*.

.N.center[
Participants of this training are assumed to be more or less familiar  
with using Vivado via the GUI.
]

---
template: plain
name: using_vivado_tcl_commands
header: ### Using Vivado Tcl Commands

Besides preparing and elaborating a Design Model via the Vivado GUI there is
also a Programming Language Interface.

.N.center[
Using Vivado via that interface is at the center of this training.
]

Though in general everything that can be achieved via the Programming Language
Interface can also be achieved via the GUI (and vice versa._[]), some deeper
knowledge of the former will pay for

* automating systematic and repeated tasks,

* including decisions what to do next.

.F[:
Though, some specific tasks may be easier in one of the two ways, and also both
approaches may intersect by assigning a sequence of Tcl commands to a GUI menu
or button.
]

---
template: plain
name: accessing_the_tool_command_language
header: ### Accessing the Tool Command Language

Technically most of the Vivado GUI is

* just an interface to an underlying data base – called the *Design Model*
* which can also be accessed – i.e. inspected and modified – via a
  *Command Language*.

More precisely, *Tcl* once developed by John Ousterhout in the mid 90s, has
been chosen as *Tool Command Language* for Vivado.

.pull-left[
Tcl is known for its
* terse,
* minimal,
* "shell"-like syntax …._[]
]
.pull-right[
… and providing core features like
* variables and data structures,
* sub-routines and flow-control,
* access to OS-services etc.
]

As a **Tool Command Language for Vivado** *Tcl* is extended with many new
commands and application specific internal data types.

.F[:
Compared more recent language developments Tcl's syntax may sometimes surprise
rather by simplicity than by complexity but with its straight forward approach
it lends itself very good for the job. The rich command set added by Vivado is
recognizably modelled following a slightly different "style" than the native
Tcl commands, which has its pro's and con's.
]

---
template: plain
name: the_vivado_tcl_console
header: ### The Vivado Tcl Console

The Vivado GUI makes a [Tcl Console](#vivado_tcl_console_details)
available which is useful for

* [Execute any Vivado Tcl Command](#vivado_tcl_console_commandline)

* but just [Watching the Tcl Console Output](#vivado_tcl_console_output)
  is also helpful to **learn the equivalent Tcl command(s)** for actions
  invoked via the GUI, like
  * preparing the in-memory design model,
  * running synthesis or implementation,
  * generating reports, or
      * for viewing or
      * modifying design objects
  * as part of design elaboration,
  * writing bitstream-files, or just

.N[
Watching the command equivalent for GUI actions in the Tcl console is an
extremely useful approach._[] if you want to find out which commands are
necessary to automate a systematic task.
]

.F[:
Besides
[Extracting Tcl Commands from a Journal](#from_journal_files_to_automation)
as is discussed later.
]

---
template: plain
name: vivado_tcl_console_details
header: #### Vivado Tcl Console Details

The Vivado Tcl Console consists of two main parts:

* An [Output Window](#vivado_tcl_console_output), showing

  * commands executed together with
  * output generated (on success) or
  * error messages (on failure)

* A [Command Line](#vivado_tcl_console_commandline), to

  * enter commands via the keyboard,
  * supporting
    * command history
    * command completion
    * command editing
  * and syntax highlighting

---
template: plain
name: vivado_tcl_console_commandline
header: #### Vivado Tcl Console Command Line

The Tcl Console Command Line is located below the Output Window.

.pull-left[
![Tcl-Console-Commandline](Tcl-Console-Commandline.png)
]
.oull-right[
The command line can be edited while typing with the usual means:

* Try Cursor-Left and -Right, Backspace, Delete etc.

It also makes previous commands available via its history feature:

* Try Cursor-Up and -Down.

Finally command completions are proposed from which one may be
selected:._[]

* Try TAB while a command typed-in is not yet complete.
]

.F[:
As completions are as soon as the window looses focus, it can not be
captured with the screen-grabbing utility.
]

---
template: plain
name: vivado_tcl_console_output
header: #### Vivado Tcl Console Output Window

Output of Tcl Commands is shown in the window **directly above** the command
line, displaying

* executed commands in blue, followed by
* ordinary output in black, or
* error messages in red (preceded by an exclamation mark).

![Tcl-Console-Output](Tcl-Console-Output.png)

Some more features may be clued from the tool buttons and decorators.._[]

.F[:
Take some time and try more things yourself, e.g. clearing all and folding all
or parts of the output.
]

---
template: plain
name: suspending_the_vivado_gui
header: ### Suspending the Vivado GUI

After starting the Vivado GUI – which is the default when running Vivado by
clicking on its icon or from terminal (= shell command line) …

.pull-left[
… entering the Tcl command
```
stop_gui
```

will temporarily suspend the GUI and place Vivado in *Tcl Mode* …
]
.pull-right[
… i.e. now you work with a raw *Tcl Shell*, from which the command

```
start_gui
```

returns to the Vivado GUI.._[]
]

In *Tcl Mode* you have all the commands available that you may use at the
command line of the *Tcl Console* in the Vivado GUI.

.N[
In most cases you will probably prefer the Vivado GUI, as it also has command
history, editing, completion and colorizing.
]

.F[:
If you have looked closely to the example showing an excerpt of what was
displayed as [Tcl Console Output](#vivado_tcl_console_output) you may have
noticed a `start_gui` command already there. It is kind of an artifact from
Vivado Starting-Up, finally switching GUI mode (unless started in `-mode batch`
`-mode tcl`).
]

---
template: plain
name: vivado_batch_script_mode
header: ### Vivado Batch Script Mode

If the only thing to run in a Vivado session is a script with (prepared) Tcl
commands, another option is to use *Tcl Batch Script Mode*.

The following will just run `my_script.tcl`:._[]
```
vivado -mode batch -source my_script.tcl
```

It is equivalent to running Vivado in in *Tcl Mode* with
```
vivado -mode tcl
```

and then enter the command
```
source my_script.tcl
```

or to type this to the command line of the Tcl console command after starting
up the Vivado GUI.

.F[:
Assumed here is that Vivado (i.e. the executable program name) is in your
command search path so that the command `vivado` runs the design suite.
]

---
template: plain
name: from_journal_files_to_automation
header: ### Form Journal Files to Automation

To get an initial Tcl script for work-flow to automate, it is often easiest to

* start an interactive (GUI) Vivado session,
* run the typical (exemplary) steps by using GUI controls,
* extract the Tcl commands actually run from the Journal File.

.N[
The standard location where Vivado stores Journals and Log-Files._[] is usually
in some way related to your "Home" directory.
]

If you have no idea where the files might be located, try a search for

* `vivado*.jou` or
* `vivado*.log`

where files with a numeric part in their name are usually backups from older
sessions and files without are from the most recent session.

.F[:
In principle Tcl commands could be extracted from both, Journal or Log-Files.
But the latter is much more cluttered with additional information which might
only occasional be useful. (E.g. if you did not run a particularly "clean"
sequence of the commands you wanted to automate, but instead had a "long and
winding" session in which you want to locate and extract just a few parts of
special interest.
]

---
template: plain
name: turning_journals_into_tcl_scripts
header: #### Turning Journals into Tcl-Scripts

Turning a Journal into a (first version) of a Tcl command sequence stored in
a file, can be as easy as to

* remove the heading comments (all lines starting with `#`), then

* remove the first command-line containing `start_gui`

.N[
Instead of removing the heading comments completely, you may rather decide to
change it into something meaningful._[]
]

To provide some structure, you may also want to:

* Insert blank lines between groups of logically related commands.

* Add comments to commands (or command groups) of special interest.

.F[:
In other words: the point is to get rid of any content which is useless or even
misleading to those who later look at the file and want to find out what it does
and how its achieves important intermediate goals.
]

---
template: plain
name: journal_to_tcl_scripts_example_1
header: ##### Example for Turning Journal into Tcl-Script (1)

Beginning of original journal:
```
#-----------------------------------------------------------
# Vivado v2016.4 (64-bit)
# SW Build 1756540 on Mon Jan 23 19:11:19 MST 2017
# IP Build 1755317 on Mon Jan 23 20:30:07 MST 2017
# Start of session at: Sun Apr  9 16:41:38 2017
# Process ID: 8490
# Current directory: /home/martin
# Command line: vivado
# Log file: /home/martin/vivado.log
# Journal file: /home/martin/vivado.jou
#-----------------------------------------------------------
start_gui
open_project /home/martin/project_1/project_1.xpr
reset_run synth_1
…
```

---
template: plain
name: journal_to_tcl_scripts_example_2
header: ##### Example for Turning Journal into Tcl-Script (2)

Parts kept as Tcl-command sequence:
```
open_project /home/martin/project_1/project_1.xpr
reset_run synth_1
launch_runs synth_1 -jobs 2
wait_on_run synth_1
open_run synth_1 -name synth_1
launch_runs impl_1 -jobs 2
wait_on_run impl_1
close_design
open_run impl_1
open_run synth_1 -name synth_1
report_timing_summary -delay_type min_max -report_unconstraineds
 -check_timing_verbose -max_paths 10 -input_pins -name timing_1
set_property STEPS.WRITE_BITSTREAM.ARGS.RAW_BITFILE true
 [get_runs impl_1]
launch_runs impl_1 -to_step write_bitstream -jobs 2
wait_on_run impl_1
```

.N.center[
Lines shown indented by one space above actually form  
**one single (long) line** in the Tcl-command script.
]

---
template: plain
name: journal_to_tcl_scripts_example_2
header: ##### Example for Turning Journal into Tcl-Script (3)

Tcl script with some parts removed and re-formatted for readability:._[]

```
# project to work with (has been created manually before)
#
open_project /home/martin/project_1/project_1.xpr

# run synthesis and implementation (as separate steps)
#
launch_runs synth_1 -jobs 2
wait_on_run synth_1
launch_runs impl_1 -jobs 2
wait_on_run impl_1

# create a bitstream file as "raw" bitfile
#
set_property\
    STEPS.WRITE_BITSTREAM.ARGS.RAW_BITFILE true\
    [get_runs impl_1]
launch_runs impl_1 -to_step write_bitstream -jobs 2
wait_on_run impl_1
```

.F[:
For the moment, do not waste too many thoughts on the exact the content of the
example: it is only meant to demonstrate that the Tcl commands extracted from
the journal may not be used as found – "1:1" – but in a modified form.
]

---
template: plain
name: plain_use_vs_packaging_in_procs
header: ### Plain Use vs. Packaging in `proc`s

When you finally have extracted the Tcl commands to be executed (maybe
augmented by comments), there are two options:._[]

* Just provide the command sequence in a file.

* In addition wrap the command sequence in a Tcl `proc`.

.pull-left[
```
# my fine design
# (non-project mode)
read_vhdl …
read_xdc …
…
synth_design …
opt_design …
…
write_bitstream …
```
]
.pull-right[
```
proc my_fine_design {} {
    read_vhdl …
    read_xdc …
    …
    synth_design …
    opt_design …
    …
    write_bitstream …
}
```
]

The second approach adds only little overhead but lends itself much
better to later refinements. 

.F[:
In the first case, when the file is `source`-d, the commands are immediately
executed.  In the second case only the subroutine `my_fine_design` is defined
which then needs to be explicitly executed.
]

---
template: plain
name: bring_in_your_own_design
header: ### Bring-in Your Own Design?

Up to this point, Vivado's Example Projects has been used, mostly as they are
easily accessible.

.N.center[
Feel free to bring-in your own design – or parts of it.
]

As long as missing Tcl-knowledge is the gap to fill, the trainer will be happy
to answer any questions based on a design you brought-in, or on examples you
created yourself during the next days.

.W[
Make sure you do not accidentally disclose parts of your work your employer
might want to be kept secret, as for technical and formal reasons it would be
difficult to get a legally binding NDA between you, the trainer and all
participants.
]

---
template: plain
name: tcl_vivado_integration
header: ## Tcl Vivado Integration

------------------------------------------------------------------------------
* [Tcl and Vivado – The Big Picture](#tcl_vivado_big_picture)

    * [Non-Project- vs. Project Mode](#nonproject_vs_project_mode)
    * [Interacting with the Design Model](#interacting_with_the_design_model)

* [Vivado Command Conventions](#vivado_command_conventions)

    * [Tcl vs. Vivado Commands](#tcl_vs_vivado_commands)
    * [Necessity of Quoting](#necessity_of_quoting)
    * [Storing Command Parameters](#storing_command_parameters)
------------------------------------------------------------------------------
* [Diving Deeper Into Vivado …](#diving_deeper_into_vivado)

  * [Understanding Non-Project Mode](#understanding_non_project_mode)
  * [Understanding Project Mode](#understanding_project_mode)
  * [Understanding the Design Model](#understanding_the_design_model)
     * [Basics of Design Navigation](#basics_of_design_navigation)
     * [Accessing Object Properties](#accessing_object_properties)
------------------------------------------------------------------------------

---
template: linkinfo
graphic: Tcl_Vivado_Integration
name: tcl_vivado_big_picture
header: ### Tcl and Vivado – The Big Picture

* Being
  **A *Tool Command Language* by Design** …

* … Tcl lends itself perfectly as scripting language for Vivado …

* … though the added commands not always follow conventions and
  style of (native) Tcl

---
template: linkinfo
graphic: VivadoDesignFlows
name: from_design_model_to_bitstream
header: #### From Design Model to Bitstream

* The typical final goal of any design is the *Bitstream File*

* Before this can happen the design usually needs some elaboration

* (Thorough testing not shown here – though highly to recommend
  before generating and using a bitstream file)


.F[:
Of course there are many reasons why a bitstream file might be never produced.
E.g. a design could turn out to be inappropriate during elaboration or
testing and is completely overturned. Or the goal is to just to test tools
Vivado uses internally. Finally, the bitstream files eventually produced
during this workshop are also not of much interest … (and will probably
never be loaded to a concrete hardware).
]

---
template: linkinfo
graphic: VivadoModesAndTcl
name: nonproject_vs_project_mode
header: #### Non-Project vs. Project Mode

* *Non-Project Mode* and *Project Mode* are two ways to use Vivado
  during design elaboration …

* … but the difference is **not** how much of the work is done via
  GUI and how much with Tcl

---
template: plain
name: general_design_activities
header: ##### General Design Activities

From a general viewpoint activities in *Non-Project-* **and** *Project-Mode* are:

1. Prepare the Design Model

2. Elaborate the Design (maybe minimal on first run through)

3. Synthesize the Design – **maybe go back** to step 2

4. Implement the Design – **maybe go back** to step 2 or 3

5. Optimize the Design – **maybe go back** to step 2, 3, or 4

6. Generate Bitstream Output

.N[
Decisions to branch back typically depend on various ways of *proofing*._[]
the design – as far as currently elaborated – will work according to its
specification on real hardware.
]

.F[:
The term "proof" is used here as well in a loose and also a broad meaning: it
may range from visual inspections of reports and simulation run results to half
or fully automated constraint checking that may cause a critical elaboration
step to fail, thereby "blocking the road" to continue.
]

---
template: plain
name: interacting_with_the_design_model
header: #### Interacting with the Design Model

How to interact with the in-memory design model._[] depends on how it is easier
to grasp

* the information to extract while exploring the design, and

* the actions to necessary to take for modifying the design.

.N[
Often the border-line is not clearly drawn, so familiarity with both, the
Vivado GUI and its Tcl Command Language is worth while.
]

.F[:
In principle, the Design Model is just an internal data base representing all
details of a design as interconnected "objects" of various "classes" in kind of
an "in memory data base". The Vivado GUI provides various "views" to inspect
and modify the contained objects in great detail, where modifications ranges
from trivial (e.g. changing a single property of a single object) to extremely
complex (e.g. generate an elaborated design from VHDL or Verilog source files).
As the model is both, *accessible* and *modifiable* via the *Tcl*-commands,
any kind of complex 
]

---
template: plain
name: exploring_the_design_model_via_gui
header: ##### Exploring the Design Model via GUI

The various graphical representations of a design and ways to

.center[
*"zoom in and out"*
]

going from a broad design overview to its nitty-gritty
details and back are too numerous to list here.

**Noteworthy points are:**

* The GUI may well be useful to
  * get an overview over the various reports generated, and
  * to display selected reports for "visual" consumption.

* The actual **content** of most reports is a textual representation
  * primarily intended to be inspected by a "human reader"._[], but
  * may very well be processed by Tcl, e.g.
     * to drill deeper to very specific information,
     * difficult hard to spot by a cursory glance.

.F[:
Of course, reports generated may also have a long-term value to document
attributes as part of a formal documentation to certify critical design goals
have been met.
]

---
template: plain
name: exploring_the_design_model_via_tcl
header: ##### Exploring the Design Model via Tcl

By using Tcl as command language there are two basically different ways to
explore the in-memory design model:

* Using specific Tcl commands to
  * [**first locate** the design object(s)](#basics_of_design_navigation)
    of interest,	
     * either simply by their name or class
     * or also by tracing their connections
       with each other,
  * [**then query** the property](#accessing_object_properties)
    of interest.

* Generate some [Standard Report](#generating_standard_reports)
  * then [**further analyze** it](#selecting_parts_of_reports)
  * with [Tcl's String Processing](#basic_string_processing) or
    [Regular Expression](#working_with_regular_expressions) capabilities.

.N.center[
Especially Tcl's versatile *Regular Expressions* come in handy here.._[]
]

.F[:
If you need some more motivation to gain experience with the Tcl language
core, also understand that learning Tcl may be beneficial for more than
improving your day-to-day work with Vivado. As Tcl is a stand-alone scripting
language it has many more applications, from providing small tools for your own
use or to distribute among colleagues, to implementing high-level control logic
and other not too time critical parts like a GUI or web interface for the
hardware solution you develop.
]

---
template: plain
name: modifying_the_design_model_via_gui
header: ##### Modifying the Design Model via GUI

Basically a large number of actions that

* can be selected from a menu or
* caused by pressing a button

will result in a modification of the in-memory design model.._[]

Depending on the currently open views such actions

* may or may not give a **direct** visual feed back,

* though Vivado usually goes to great lengths aiming to provide optimal user
  experience by clearly indicating
  * still ongoing operations, and
  * failure or success when completed.

* Furthermore often a choice of next actions to take is proposed when some
  major step completes.


.F[:
This is especially true if that design model representation is understood in
the broad way it is applied by Vivado, i.e. not only for storing and
manipulating "objects" with a concrete mapping to a physical device (LUTs,
Ports, Wires, …), but also parameters of design runs, optimisation strategies,
details for creating bitstream files … and much, **much**, **MUCH** more.
]

---
template: plain
name: modifying_the_design_model_via_tcl
header: ##### Modifying the Design Model via Tcl

For many of the prominent actions to be carried out via the Vivado GUI
there are equivalent Tcl commands. As such actions are too many to list here,
also the Tcl commands are.

Besides via specific commands for some modifications of the design model a
different route needs to be taken:

* Use the specific Tcl commands to

  * [**first locate** the design object(s)](#basics_of_design_navigation)
    of interest,	
     * either simply by their name or class
     * or by tracing their connections with each other,
  * [**then set** the property](#accessing_object_properties)
    of interest as required.

.N[
Navigating through complex networks of design objects for finding the ones of
interest may require understanding Tcl (slightly) beyond the level of simple
list handling and `foreach`-loops.._[]
]

---
template: plain
name: vivado_command_conventions
header: ### Vivado Command Conventions

As already has been mentioned Tcl commands

* evaluate their arguments themselves (each)

* hence achieve "uniformity" by following conventions only

* where *Tcl Style* and *Vivado Style* slightly differs

.N.center[
Differences are not quite from separate worlds but visible enough.
]

Therefore it may pay to be aware of a command's origin – Tcl or Vivado.._[]

.F[:
Similar to being aware whether driving a gear-shifting car or a car with
automatic transmission – Tcl is more on the gear-shifting side, Vivado more
on the other (author's advice and personal opinion).  
The reasons for the differences are manifold and partially speculative:
(1) Tcl itself is not completely "as if made from one piece" and therefore
not quite consistent. (2) There may have been the intent to be more
"user friendly" in Vivado. (3) Scarce resources originally guiding some
Tcl design decisions are no longer an issue today.
]

---
template: linkinfo
graphic: VivadoVsTclSyntax
name: tcl_vs_vivado_commands
header: #### Tcl vs. Vivado Commands

* **Common** to Tcl and Vivado is Syntax Analysis only.

* Beyond that, slightly different styles between

  * [Tcl Builtin Commands](#typical_tcl_builtin_command_style) and
  * [Tcl Vivado Commands](#typical_tcl_vivado_command_style)

become apparent.


---
template: plain
name: typical_tcl_builtin_command_style
header: ##### Typical Tcl Builtin Command Style

* Most Tcl Builtin Commands._[] follow a few simple rules, e.g.
     * options are indicated by a dash and a "keywords"
     * and typically come first, then "ordinary" arguments

* Error messages are terse and use kind of a meta-syntax, e.g. indicating
     * optional parts by enclosing in question marks (`?`……`?`) or
     * optional repetition by three dots (…… ` ...`)

* There is no builtin help, e.g.
  * if correct usage can not be gleaned from the (terse) error message given
    for usage errors
  * typically the (online) manual needs to be consulted.

.F[:
There are a few exceptions in "uniformity" caused by the growth of Tcl in the
early days, leading to today's style of "command collections" with a "master
command" and "sub-commands" like e.g. seen in the `string` or `file` commands.
In contrary the (somewhat older) commands for list processing like `lindex`,
`llength` etc. simply all have a lower case "ell" as their first letter.
]

---
template: plain
name: typical_tcl_vivado_command_style
header: ##### Typical Tcl Vivado Command Style

* Tcl Vivado Commands exhibit **a very high degree of uniformity**

* and also often provide a rich set of options,
  * some of which – just for convenience – support typical use cases,
  * with an overall effect that could as well have been achieved by a simple
    combination with one or more generic commands._[]

* **All Tcl Vivado Commands** provide
  * a detailed usage description when the option `-help` is specified
  * which is also produced when the command is used as argument to the Vivado
    Tcl Command `help`.

.pull-left[
Two ways to get a *Online Help* …
* *`a_tcl_vivado_command`* **` -help`**
]
.pull-right[
… for *`a_tcl_vivado_command`*:
* **`help `** *`a_tcl_vivado_command`*
]

.F[:
E.g. all reports Vivado which can be generated by using Tcl commands will be
written as output onto the Tcl console by default, can alternatively be written
to a file named via the `-file` option, or can be retrieved as command return
value when the `-return_string` option is specified. In principle that last
behavior would be fully sufficient, as Tcl allows to turn **any** return value
easily into console output or – with only little more effort – write it to a
file.
]

---
template: plain
name: necessity_of_quoting
header: #### Necessity of Quoting

The Tcl syntax has two peculiarities which may come to a surprise users who
"extrapolate knowledge" gathered with different languages:

* There is **no such thing** as a "string literal"  
  (required to be enclosed in a particular kind of quotes).

* White space is **syntactically significant** as argument separator for
  commands, and

* most commands are somewhat picky wrt. to the number of arguments they
  accept.._[]

.N[
Furthermore the various steps of the syntax analysis are carried out
sequentially, **which most often make perfect sense and is also very simple to
remember**, but occasionally requires to request "a second round" which in turn
may make extra quoting necessary.
]

.F[
The most famous exceptions are the commands `expr`, `eval`, and `uplevel` which
first concatenate all their arguments to one long string which is then
interpreted according to an expression evaluation syntax (in case of `expr`) or
(another round through) the Tcl command line syntax. (Also `subst` is somewhat
similar to `eval` but substitutions can be enabled or disabled at a finer
grained level.) ]

---
template: plain
name: quoting_example_1
header: ##### Quoting Example (1)

To train your understanding how Tcl quoting works, defining the following
command `=` makes sense, which **has no other effect** as to show you how a
command line looks like

* after Tcl has carried out syntax analysis,
* including all requested substitutions,
* while honoring quoting.

.pull-left[
First define a command with the peculiar name._[] "`=`" together with some more
stuff to play with …
```
proc = {args} {
    foreach x $args {
        puts "([incr n]) >$x<"
    }
}
set a xxx
proc b { return zzz }
```
]
.pull-right[
… and use it to view the substituted form of the example commands below:
```
= puts a b c
= puts "a b c"
= puts {a b c}
= puts $a  [b] c
= puts "$a [b] c"
= puts {$a [b] c}
= puts \$a\ \[b]\ c
```
]

.F[:
The peculiar name is not the point here – the command might also be named
`show_args` or whatever.
]

---
template: plain
name: quoting_example_2
header: ##### Quoting Example (2)

As shown so far, quoting is necessary if a standard substitution of the Tcl
syntax needs to be disabled.

.pull-left[
Within double quotes there is
* **no word separation** and
* **no command separation**,
* but still substitution of
  * variable content
  * function return values
  * escape sequences for  
    non-printing characters
* also contained curly braces are taken verbatim (not as "nested quoting")
]
.pull-right[
```
= "abc    def ... xyz"
= "$a [b]         xyz"
= "$a [b]"    ... xyz
= "\$a \[b]" ...\ xyz
= "abc \"def\"... xyz"
= "\\abc\\def\\...\\xyz"
= "\\abc\\def\\...\\xyz\""
= "\\abc\\def\\...\\xyz\\"
= "$a [b]\" \"... xyz"
= "abc { [b] }"
= "} a{b c}d {"
= "} a" {b c} "d {"
= "} a" "{b c}" "d {"
```
]

(On that base, try to predict the output of the above examples.._[])

.F[:
Beware that some might not be valid syntax!
]


---
template: plain
name: quoting_example_3
header: ##### Quoting Example (3)

Meanwhile it may have become clear that the tricky part sometimes is to
understand how quoting mechanism mutually protect each other.

.pull-left[
Within curly braces
* **all content** is taken verbatim
* though
  * opening and closing braces are counted …
  * … to find the closing brace that **matches** the initial opening brace
* a backslash prior to a contained curly brace
  * **only disables counting** but
  * **is still taken verbatim**
]
.pull-right[
```
= {abc    def ... xyz}
= {$a [b]         xyz}
= {$a [b]}    ... xyz
= {abc {def ghi}  xyz}
= {abc  { ... }   xyz}
= {abc \{ ... \}  xyz}
= {abc \{ ...     xyz}
= {abc    ... \}  xyz}
= {abc \{ ... }   xyz}
= {abc  { ... \}  xyz}
= {\abc\def\...\xyz}
= {\\abc\\def\\...\\xyz}
= {\\abc\\def\\...\\xyz\\}
= {\abc\def\...\xyz\}
```
]

(On that base, try to predict the output of the above examples.._[])

.F[:
Beware that some might not be valid syntax!
]

---
template: plain
name: quoting_example_4
header: ##### Quoting Example (4)

[XILINX UG835]: http://www.xilinx.com/support/documentation/sw_manuals/xilinx2016_4/ug835-vivado-tcl-commands.pdf

In case the prior pages seemed rather "theoretical" with little practical
relevance, consider the following two examples taken from
[XILINX UG835]
 → *Ch.1 → General Tcl Syntax Guidelines*
 → *Using Special Characters*:

.pull-left[
Correctly quote the *Verilog Identifier* `\my sig\` (that contains a space and
begins and ends with a single backslash):
```
add_wave \\my\ sig\\
```
]
.pull-right[
Also try the "`=`" command on it to show the effect of the original quoting and
some variations:._[]
```
= add_wave \\my\ sig\\
= add_wave \\my\  sig\\
= add_wave \\my\\ sig\\
= add_wave "\\my sig\\"
= add_wave {\\my sig\\}
= add_wave {\my sig\}

```
]

Correctly quote a filter expressions, containing spaces:
```
get_cells * -hierarchical -filter { lib_cell == FD* && loc != "" }
```

.F[:
Beware that some might not be valid syntax!
]

---
template: plain
name: quoting_example_5
header: ##### Quoting Example (5)

The last example gets even more challenging if some parts of the comparison are
coming from a variable content.

To more clearly see the problem, first try with the "`=`" command:
```
= get_cells * -hierarchical -filter { lib_cell =~ FD* && loc != "" }
```

Now assume the string which `lib_cell` should match is stored in a variable and
predict how the Tcl syntax interprets the following:._[]
```
set fdcells "FD*"
= get_cells ... { lib_cell =~ $fdcells && loc != "" }
= get_cells ... " lib_cell =~ $fdcells && loc != "" "
= get_cells ... " lib_cell =~ $fdcells && loc != \"\" "
```

To understand the final variation you may want to look up the description of
the [Tcl command `concat`]:
```
= get_cells ... [concat lib_cell =~ $fdcells && loc != {""}]
```

[Tcl command `concat`]: https://www.tcl.tk/man/tcl8.4/TclCmd/concat.htm


.F[:
Beware that some lines might not be valid syntax!
]

---
template: plain
name: storing_command_parameters
header: #### Storing Command Parameters

[XILINX UG894]: http://www.xilinx.com/support/documentation/sw_manuals/xilinx2016_4/ug894-vivado-tcl-scripting.pdf

Also the next example is clearly a practical one, in this case taken from
[XILINX UG894]
 → *Tcl Scripting in Vivado*
 → *Writing a Tcl Script*:
```
proc reportWorstViolations {nbrPaths args} {
    eval report_timing -max_paths $nbrPaths $args
}
```

The problem which is intended to be solved with the [Tcl command `eval`] is
that a call syntax like follows shall be supported:._[]
```
reportWorstViolations 10 -delay_type min_max -nworst 2
```

.N[
Now inside the procedure `args` represents a list of all call arguments
following the first one but this lists gets expanded as space-separated words
**only after** word separators have already been evaluated.
]

.F[:
To make the problem clearly visible, replace the body of the procedure with:
```
    = report_timing -max_paths $nbrPaths $args
    = eval report_timing -max_paths $nbrPaths $args
```
]

[Tcl command `eval`]: https://www.tcl.tk/man/tcl8.4/TclCmd/eval.htm

---
template: plain
name: quoting_example_6
header: ##### Quoting Example (6)

The use of `eval` with variables of unknown content should always raise a
mental warning signal.

The "solution" with `eval` will fail badly in the following case:._[]

* The actual value specified for the first (`nbrPaths`) argument

  * contains anything usually evaluated by Tcl's syntax analysis **before**
    variable content gets inserted

  * **and** in the call of `report_max_timings` was correctly quoted.

.F[:
More concretely, consider the following:
```
reportWorstViolations "1 2" -delay_type min_max -nworst 2
```

In this specific case it may be argued that `nbrPaths` should be a plain
(integral) number and will never have anything like spaces embedded, so if its
content were different, `report_timing` would have failed anyway. But even then
the approach is to reject on the base it issues a misleading error message.

If you generally strive for robustness, you should also be aware that careless
use of `eval` (and also `uplevel` and some more culprits) might allow a caller
to trick a subroutine into executing any arbitrary code, which malevolent users
might use to achieve unexpected or undesired effects. Try this:
```
reportWorstViolations 1\;= -delay_type min_max -nworst 2
```

]

---
template: plain
name: quoting_example_7
header: ##### Quoting Example (7)

As a precautionary means, for each and every use of the `eval` command, go with
this fine rule:

.N[
If some parts of the whole `eval` command line are not under strict control,
**especially if they are taken from a subroutine argument**, use quoting to
avoid it undergoes two rounds of syntax analysis.
]

The preferable quoting mechanism in this case is the [Tcl command `list`]:._[]
```
proc reportWorstViolations {nbrPaths args} {
    eval report_timing -max_paths [list $nbrPaths] $args
}
```

[Tcl command `list`]: https://www.tcl.tk/man/tcl8.4/TclCmd/list.htm

.F[:
In case you want to do a more detailed analysis when and how `list` kicks in,
simply change the body code of `reportWorstViolations` to:
```
    = eval report_timing -max_paths [list $nbrPaths] $args
```

However hard you try, you will probably notice it is practically impossible to
outsmart the quoting added by `list` – `nbrPaths` always stays the one single
argument the caller handed over.
]

---
template: plain
name: diving_deeper_into_vivado
header: ### Diving Deeper Into Vivado …

From here be sure to follow the live examples as presented by the trainer.

A purely "static presentation" (with screen shots etc.) will be of little
value when compared to

* watch the "live" output of the examples given,

* also trying them out yourself,

* preferably not only as demonstrated, but

  * with small modifications,

  * for which you try to predict the result.

.N.center[
Feel free to get help from the trainer at any time and  
for any finding you cannot fully explain yourself.
]

---
template: plain
name: understanding_non_project_mode
header: #### Understanding Non-Project Mode

Compared to Project Mode, Non-Project mode gives more **direct** control over

* Which and especially when HDL source files gets compiled.

* The sequence in which tools are used for

  * synthesis,
  * implementation,
  * routing, etc.

* The various optimization steps executed (or skipped) and how they are
  parametrized in detail.

Also generating the bitstream file is an explicit step but this is not that
much different from [Project Mode](#understanding_project_mode)
where the bitstream file is generate as part of a *Run* launched with the
option `-to bitstream`.

.N[
If you are lacking any experience with Vivado's Non-Project Mode it is
suggested to work through [XILINX UG888] → *Lab 1*.
]

[XILINX UG835]: http://www.xilinx.com/support/documentation/sw_manuals/xilinx2016_4/ug835-vivado-tcl-commands.pdf
[XILINX UG888]: http://www.xilinx.com/support/documentation/sw_manuals/xilinx2016_4/ug888-vivado-design-flows-overview-tutorial.pdf

---

template: plain
header: ##### Non-Project Mode Tcl Commands (Overview)

Non-Project Mode Commands can be roughly categorized into:

* Preparing Elaboration from HDL file and other (re-) sources
  * using various `read_`-commands
  * resulting in the content of the files are made part of the in-memory
    design.

* Synthesizing Design
  * using `synth_design` which also
  * opens the design for inspection and further elaboration.._[]

* Implementing the Design
  * using `opt_design`, `place_design`, `phys_opt_design`
  * and finally `write_bitstream`

.F[:
Actually elaborating the design by generating and reviewing reports, running
simulations etc. is not that different from [Project Mode].
]

---
template: plain
header: ##### Non-Project Mode Commands to Prepare Elaboration

There are a number of commands to process various kinds input (source) files,
like
.pull-left[
* `read_verilog`
* `read_vhdl`
* `read_ip`
* `read_bd`
* `read_xdc`
* `read_edif`
]
.pull-right[
.N.center[
With all these commands be sure to understand that  
**backslashes basically still are a Tcl mechanism for quoting and substituting
non-printable characters**.
]
]

Therefore prefer forward slashes as path name separators.._[]

-------------------------------------------------------------------------------

Besides the above there are other `read_`-commands with a more specialized
purpose.

.F[:
In Tcl forward slashes equally work as path name separators for all Operating
Systems, i.e. Microsoft Windows **and** Linux (and any OS with a file system
in the U*ix tradition).
]

---
template: plain
header: ##### More Non-Project Mode Commands To Prepare Elaboration

Other commands that are possibly relevant for preparing design elaboration are:

* `read_checkpoint` – to (re-) start from a design state saved with  
  `write_checkpoint`
* `set_param` and `set_property` (e.g. to set design tool options)
* `link_design`

.I[
For further information in overview style see
[XILINX UG892]
 → *Ch. 4*
 → *Reading Design Sources*.  
For a detailed description see
[XILINX UG835]
 → *Ch. 3: Tcl Commands Listed Alphabetically*
]

[XILINX UG892]: http://www.xilinx.com/support/documentation/sw_manuals/xilinx2016_4/ug892-vivado-design-flows-overview.pdf
[XILINX UG835]: http://www.xilinx.com/support/documentation/sw_manuals/xilinx2016_4/ug835-vivado-tcl-commands.pdf

---
template: plain
name: synthesizing_a_design
header: ##### Synthesizing a Design (in Non-Project Mode)

There is exactly one command for that purpose:._[]

* `synth_design`

There are many options to control many details of logic synthesis.

.I[
For further information in overview style see
[XILINX UG892]
 → *Ch. 4*
 → *Running Logic Synthesis and Implementation*
For a detailed description see
[XILINX UG835]
 → *Ch. 3: Tcl Commands Listed Alphabetically*
]

[XILINX UG892]: http://www.xilinx.com/support/documentation/sw_manuals/xilinx2016_4/ug892-vivado-design-flows-overview.pdf
[XILINX UG835]: http://www.xilinx.com/support/documentation/sw_manuals/xilinx2016_4/ug835-vivado-tcl-commands.pdf

.F[:
Note that this command will also be used in Project Mode, but not directly then,
instead as part of pre-defined *Runs*.
]

---
template: plain
name: implementing_a_design
header: ##### Implementing a Design (in Non-Project Mode)

There are several commands for that purpose:._[]

.pull-left[
* `opt_design`
* `place_design`
* `phys_opt_design`
* `route_design`

The tools above must be run  
**in the order shown**.
]
.pull-right[
The tool below may be be inserted **before or after** `place_design`:

* `power_opt_design`
]

It may also make sense to [safe the current state](#using_checkpoints) of an
elaboration between individual steps so that it can be easily restored.

.I[
For further information in overview style see
[XILINX UG892]
 → *Ch. 4*
 → *Running Logic Synthesis and Implementation*
For a detailed description see
[XILINX UG835]
 → *Ch. 3: Tcl Commands Listed Alphabetically*
]

[XILINX UG892]: http://www.xilinx.com/support/documentation/sw_manuals/xilinx2016_4/ug892-vivado-design-flows-overview.pdf
[XILINX UG835]: http://www.xilinx.com/support/documentation/sw_manuals/xilinx2016_4/ug835-vivado-tcl-commands.pdf

.F[:
Note that these commands will also be used in Project Mode, but not directly
then, instead as part of pre-defined *Runs*.
]

---
template: plain
name: generating_standard_reports
header: ##### Generating Standard Reports

There are more that 50 commands to generate reports:
.pull-left[
* `report_bps`
* `report_bus_skew`
* …
* `report_timing`
* `report_timing_summary`
* …
* `report_utilization`
* `report_values`
]
.pull-right[
To get an overview is left to the each participant.

(Including how each report-generating command can be controlled at a
fine-grained level for the amount of information contained in that report.)
]

Reports may also serve as a base to
[extract more specific information](#further_processing_reports).

.I[
For further information in overview style see
[XILINX UG892]
 → *Ch. 4*
 → *Generating Reports*  
For a detailed description see
[XILINX UG835]
 → *Ch. 3: Tcl Commands Listed Alphabetically*
]

[XILINX UG892]: http://www.xilinx.com/support/documentation/sw_manuals/xilinx2016_4/ug892-vivado-design-flows-overview.pdf
[XILINX UG835]: http://www.xilinx.com/support/documentation/sw_manuals/xilinx2016_4/ug835-vivado-tcl-commands.pdf

---
template: plain
name: further_processing_reports
header: ##### Further Processing Reports

A common feature of all `report_*`-commands is that their output is

* sent to the Tcl Console per default;
* sent to a named file (…) with the option `-file …`;
* appended to a named file (…) with the option `-append …`;
* returned as result with the option `-return_string`.

There are two basic approaches:

* Store the report in a file, then read it back into main memory.

* Directly store the report in a variable, in main memory.

.N.center[
As these techniques are of interest in both,  
*Non-Project* and *Project Mode*,  
they will be discussed later in a
[chapter of their own](#processing_files_and_reports)
]

---
template: plain
name: using_checkpoints
header: ##### Using Check-Points

After any individual step the current state of the in-memory design …

.pull-left[
… can be saved to a file:

* `write_checkpoint`
]
.pull-left[
… may be restored from a file:

* `read_checkpoint`
]

Checkpointing may be especially advantageous if

* many different optimization are tried
* with a step-wise refinement strategy

and some turn out to be dead-ends.._[]

.I[
For further information in overview style see
[XILINX UG892]
 → *Ch. 4*
 → *Using Design Checkpoints*  
For a detailed description see
[XILINX UG835]
 → *Ch. 3: Tcl Commands Listed Alphabetically*
]

[XILINX UG892]: http://www.xilinx.com/support/documentation/sw_manuals/xilinx2016_4/ug892-vivado-design-flows-overview.pdf
[XILINX UG835]: http://www.xilinx.com/support/documentation/sw_manuals/xilinx2016_4/ug835-vivado-tcl-commands.pdf

.F[:
Of course, on the long run, this approach just **calls** for being further
automated by Tcl scripting.
]

---
template: plain
header: ##### Writing a Bitstream-File

This is done with the command

* `write_bitstream`

For its direct use in Non-Project Mode._[] there are options to control some details
of its behavior.

.I[
For a detailed description see
[XILINX UG835]
 → *Ch. 3: Tcl Commands Listed Alphabetically*
]

[XILINX UG892]: http://www.xilinx.com/support/documentation/sw_manuals/xilinx2016_4/ug892-vivado-design-flows-overview.pdf
[XILINX UG835]: http://www.xilinx.com/support/documentation/sw_manuals/xilinx2016_4/ug835-vivado-tcl-commands.pdf

.F[:
Note that this commands will also be used in Project Mode, but not directly
then, instead as part of pre-defined *Runs*.
]


---
template: linkinfo
graphic: VivadoProjectMode
name: understanding_project_mode
header: #### Understanding Project Mode

* Relationships in *Project Mode* need some more explanation

* Basically it automates managing dependencies between files while minimising
  tool use

* Also options for various optimisation runs are specified in a packaged
  form, called *Strategies*

---

template: plain
header: ##### Project Mode Tcl Commands (Overview)

In Project Mode

* first a project must be *created* (once)

* to which then HDL sources are *added* and

* for which *Runs* will be defined, that

* can then be *launched*.

.N[
If you are lacking any experience with Vivado's Project Mode it is
suggested to work through [XILINX UG888] → *Lab 2*.
]

[XILINX UG888]: http://www.xilinx.com/support/documentation/sw_manuals/xilinx2016_4/ug888-vivado-design-flows-overview-tutorial.pdf

---

template: plain
header: ##### Creating New Projects

.pull-left[
New projects are either created from scratch using …

* `create_project`
]
.pull-right[
… or may be imported:

* `import_synplify`
* `import_xise`
* `import_xst`
]

Projects are usually associated with files in non-volatile memory._[], i.e.  they are persistent between separate Vivado sessions.

.I[
For further information in overview style see
[XILINX UG892]
 → *Ch. 3*
 → *Creating Projects* and  
 → *Ch. 3*
 → *Creating Projects*
 → *Different Types of Projects*  
For a detailed description see
[XILINX UG835]
 → *Ch. 3: Tcl Commands Listed Alphabetically*
]

[XILINX UG892]: http://www.xilinx.com/support/documentation/sw_manuals/xilinx2016_4/ug892-vivado-design-flows-overview.pdf
[XILINX UG835]: http://www.xilinx.com/support/documentation/sw_manuals/xilinx2016_4/ug835-vivado-tcl-commands.pdf

.F[:
With the exception of projects that are created with the `-in_memory` option,
for which the documentation hints they may be useful for in a mixed
*Project-/Non-Project* Design Flow, but discourages from using this option
at the same time.
]

---
template: plain
header: ##### Preparing a Project for Elaboration

Vivado may have several projects open at the same time.

.N.center[
But only one project can be the **current project**.
]

Related commands are:

* `open_project` – create an in-memory representation for an existing project
  (from an `*.xpr` or `*.lpr` file)
* `close_project` – remove the in-memory representation of a project._[]
* `current_project` – query or set the current project
* `get_property` – access and
* `set_property` – modify details of a project

.I[
For a detailed description see
[XILINX UG835]
 → *Ch. 3: Tcl Commands Listed Alphabetically*
]

[XILINX UG835]: http://www.xilinx.com/support/documentation/sw_manuals/xilinx2016_4/ug835-vivado-tcl-commands.pdf

.F[:
By adding the option `-delete` also the `*.xpr` or `*.lpr` file will be removed.
]

---
template: plain
header: ##### Adding Source Files to a Project

Source files belonging to some project are managed via *File Sets*.

.N[
There are several file sets for different purpose, like HDL sources,
simulation sources, constraints, or IP Subsystems.
]

Related commands are:

* `add_file` – add one or more files to a file set  
  (only references the file location in the project)
* `import_file` – add one or more files to a file set and  
   **copy that file into the project's directory structure**
* `import_ip` – import IP Subsystem

.I[
For further information in overview style see
[XILINX UG892]
 → *Ch. 3*
 → *Managing Source Files in Project Mode*  
For a detailed description see
[XILINX UG835]
 → *Ch. 3: Tcl Commands Listed Alphabetically*
]

---
template: plain
header: ##### Archiving and Recreating Projects

There are several ways to copy a project:

* `archive_project` – basically saving the project's directory structure into
  a ZIP-file
* `write_project` – creating a Tcl script to re-generate the project in its
  current state (of course including the content of all source files)
* `save_project-as` – writes (clones) the current project (`*.xpr` or `*.lpr`
  file) at a different new location

.N[
As the documentation points out, the Tcl script created by `write_project` may
be checked-in into a version control system.
]

Then, at any time later, the project with all its state at that moment can be
restored, e.g. to branch-out a version for making bug fixes.

.I[
For further information in overview style see
[XILINX UG892]
 → *Ch. 3*
 → *Managing Source Files in Project Mode*
 → *Archiving Projects* + *Creating a Tcl Script to Recreate Projects*  
For a detailed description see
[XILINX UG835]
 → *Ch. 3: Tcl Commands Listed Alphabetically*
]

[XILINX UG892]: http://www.xilinx.com/support/documentation/sw_manuals/xilinx2016_4/ug892-vivado-design-flows-overview.pdf
[XILINX UG835]: http://www.xilinx.com/support/documentation/sw_manuals/xilinx2016_4/ug835-vivado-tcl-commands.pdf

---

template: plain
header: ##### Defining and Launching Runs

In Project Mode

* Defining *Runs* that can
* then be *launched*

replace the explicit use of the respective Non-Project Mode commands for
[Synthesizing](#synthesizing_a_design) and
[Implementing](#implementing_a_design) a Design.

.I[
For further information in overview style see
[XILINX UG892]
 → *Ch. 3*
 → *Running Logic Synthesis and Implementation*  
]

[XILINX UG892]: http://www.xilinx.com/support/documentation/sw_manuals/xilinx2016_4/ug892-vivado-design-flows-overview.pdf

---
template: plain
name: defining_runs_with_tcl_commands
header: ##### Defining Runs with Tcl Commands

Besides using the Vivado GUI there are also Tcl commands to define *Runs*:

* `create_run` – will define a new Design Tool *Run*,
   * either for a *Synthesis Tool*
   * or for (a set of) *Implementation Tool(s)*
* `current_run` – query or set the current run
* `get_property` – access and
* `set_property` – modify details of a run

.N.center[
Whether a *Run* is created as *Synthesis* or *Implementation*  
is determined by its `-flow` and `-parent` options.._[]
]

Runs with a *Parent* are *Implementation Runs*, which – via the *Parent Run* –
are related to the respective *Synthesis Run* (that itself has no parent).

.I[
For a detailed description see
[XILINX UG835]
 → *Ch. 3: Tcl Commands Listed Alphabetically*
]

[XILINX UG835]: http://www.xilinx.com/support/documentation/sw_manuals/xilinx2016_4/ug835-vivado-tcl-commands.pdf

.F[:
The documentation is not very enlightening in this respect but seems to
indicate the `-flow` option allows two pre-defined values only.
]

---
template: plain
name: launching_runs_with_tcl_commands
header: ##### Launching Runs with Tcl Commands

Besides using the Vivado GUI there are also Tcl commands for launching
(and further controlling) *Runs*:

* `launch_runs` – launch one or more runs
* `wait_on_run` – wait for a specific run to terminate

.N.center[
When launching a *Run* the target specified, i.e.  
up to achieving which "goal" the tools should be run.
]

Vivado in *Project Mode* is capable to organize *Incremental Compiles* by (re-)
starting from intermediate checkpoints.

.I[
For a detailed description see
[XILINX UG835]
 → *Ch. 3: Tcl Commands Listed Alphabetically*
]

[
XILINX UG835]: http://www.xilinx.com/support/documentation/sw_manuals/xilinx2016_4/ug835-vivado-tcl-commands.pdf
---
template: plain
name: organizing_optimizations_via_strategies
header: ##### Organizing Optimizations via Strategies

Compared to the *Non-Project Design Flow*, where especially the various
optimisation steps are called explicitly in a (mostly) fixed order,
*Project Mode* takes a slightly different approach.

* For the optimization steps typical *Parameter Collections* are defined.
* These collections are descriptively named and selected name.

In Vivado's GUI Mode Strategies are part of and can be modified per
*Implementation Run*.

With regard to the Vivado's Tcl Language Interface this is reflected into
modifying properties of a *Implementation Run* object.

.I[
Compared to most other aspects of controlling Vivado via Tcl this is not so
well documented but some clues about the general approach can be taken from
[XILINX UG835]
 → *Ch. 3: Tcl Commands Listed Alphabetically*
 → `launch_runs`
 → Examples (last paragraph of section)
]

---
template: plain
name: understanding_the_design_model
header: ### Understanding the Design Model

Prior to navigating._[] within the design using Tcl commands there needs to be
a basic understanding of the model itself.

This requires to

* [Understandig Design Objects](#understanding_design_objects) and

* Understanding the [Basics of Design Navigation](#basics_of_design_navigation)

.I[
For more information refer to:  
[XILINX UG894] **Using Tcl Scripting** – for an Introduction  
[XILINX UG912] **Properties Reference Guide** – More Details  
[XILINX UG835] **Vivado Tcl Commands** – Complete Reference
]

[XILINX UG894]: http://www.xilinx.com/support/documentation/sw_manuals/xilinx2016_4/ug894-vivado-tcl-scripting.pdf
[XILINX UG912]: http://www.xilinx.com/support/documentation/sw_manuals/xilinx2016_4/ug912-vivado-properties.pdf
[XILINX UG835]: http://www.xilinx.com/support/documentation/sw_manuals/xilinx2016_4/ug835-vivado-tcl-commands.pdf

.F[:
Navigating the in-memory design model is usually the first step to select one
or more objects, which subsequently are accessed or modified.
]

---
template: plain
name: understanding_design_objects
header: #### Understanding Design Objects

*Design Objects* are Data Entities._[] used internally in Vivado for various
purposes.

As such they hold

* a set of data values – called properties – that can be accessed for
  reading, and

* most of which can also be modified.

.I[
For further introduction see also Appendix [Design Object Overview],
reproducing some relevant chapters from [XILINX UG912].
]

[Design Object Overview]: file:PDF/ug912_part-design_object_overview.pdf
[XILINX UG912]: http://www.xilinx.com/support/documentation/sw_manuals/xilinx2016_4/ug912-vivado-properties.pdf

.F[:
Compared to the traditional meaning of the term *Object* in OOP-Languages the
*Design Objects* as used in Vivado are missing *Methods*.
]

---
template: plain
name: design_objects_example_commands
header: ##### Design Objects Example Commands

Assuming `$obj` already holds a valid design object, some useful commands to
further inspect that object are:
```
report_property $obj
get_property NAME $obj
get_property CLASS $obj
```

---
template: plain
name: basics_of_design_navigation
header: #### Basics of Design Navigation

Navigating to objects in the in-memory design model is similar to navigating
to files in a directory tree, i.e.

* many of the important design objects have structured names,

* which is referred-to relative to the current top (element)

* or by navigation from related objects via `-of_object`._[]

.I[
For further introduction see also Appendix [Design Object Navigation],
reproducing some relevant chapters from [XILINX UG894].
]

[Design Object Navigation]: file:PDF/ug894_part-design_object_navigation.pdf

[XILINX UG894]: http://www.xilinx.com/support/documentation/sw_manuals/xilinx2016_4/ug894-vivado-tcl-scripting.pdf
[XILINX UG835]: http://www.xilinx.com/support/documentation/sw_manuals/xilinx2016_4/ug835-vivado-tcl-commands.pdf

.F[:
For basic and even for moderately ambitious tasks it is fully sufficient to
grasp the main relationships while ignoring the details. For the full
picture see: *[XILINX UG835] → Ch. 1: Introduction → First Class Tcl Objects and
Relationships  → Object Relationships*
]

---
template: plain
name: design_navigation_example_commands
header: ##### Design Navigation Example Commands

Assuming a synthesized design is already open, the following examples
demonstrate various ways to navigate to single object or through object lists.

.N.center[
A Demonstration will be given live.
]

---
template: plain
header: #### Filtering Result Lists on Object Properties

Object lists returned._[] when looking-up navigating through design objects may
be also filtered to only contain objects adhering to a filter specification:

.N.center[
A Demonstration will be given live.
]

.F[:
Be sure to understand that object list can only contain objects of the same
class – objects of different classes need to be held in separate lists.
]


---
template: plain
name: accessing_object_properties
header: #### Accessing Object Properties

Design object properties are generally accessed with

* `get_property` to get the current value, and

* `set_property` to modify the current value

.pull-left[
Retrieving property `XXX` of a **single object** held by `$obj`, storing its
value in variable `v`:
```
set v [get_property XXX $obj]
```
]
.pull-right[
Modifying property `XXX` assume the new value `nval` for **one or more**
objects held by `$objs`:
```
set_property XXX nval $objs
```
]

---
template: plain
name: processing_files_and_reports
header: ## Processing Files and Reports

------------------------------------------------------------------------------

* [Scanning Directories](#scanning_directories)

* [Basic (Text) File Processing](#basic_file_processing)

* [Basic String Processing](#basic_string_processing)

* [Selecting Parts of Reports](#selecting_parts_of_reports)

* [Working with Regular Expressions](#working_with_regular_expressions)

------------------------------------------------------------------------------

---
template: plain
name: scanning_directories
header: ### Scanning Directories

[Tcl command `glob`]: https://www.tcl.tk/man/tcl8.4/TclCmd/glob.htm
[Tcl command `cd`]: https://www.tcl.tk/man/tcl8.4/TclCmd/cd.htm
[Tcl command `pwd`]: https://www.tcl.tk/man/tcl8.4/TclCmd/pwd.htm
[Tcl command `file`]: https://www.tcl.tk/man/tcl8.4/TclCmd/file.htm

* The [Tcl command `glob`] is the basic way to scan a directory for the entries
  it contains.

* Recursively descending into subdirectories can be achieved with the
  [Tcl command `cd`] …

* … while the [Tcl command `pwd`] might be used to store the current working
  directory to return to it later.

* While scanning directory entries the command `file` may sometimes be useful
  as it provides typical operations with whole files.

.N.center[
A Demonstration will be given live.
]

---
template: plain
name: basic_file_processing
header: ### Basic (Text) File Processing

[Tcl command `open`]: https://www.tcl.tk/man/tcl8.4/TclCmd/open.htm
[Tcl command `close`]: https://www.tcl.tk/man/tcl8.4/TclCmd/close.htm
[Tcl command `catch`]: https://www.tcl.tk/man/tcl8.4/TclCmd/catch.htm
[Tcl command `read`]: https://www.tcl.tk/man/tcl8.4/TclCmd/read.htm
[Tcl command `gets`]: https://www.tcl.tk/man/tcl8.4/TclCmd/gets.htm

* The [Tcl command `open`] provides basic to the current content of a file
  (when opened for reading) or to replace its content or append to it.

* With the [Tcl command `catch`] adequate error handling can – and should – be
  added around opening a file.

* To free resources no longer used the [Tcl command `close`] should be used
  when access to some file is no longer required.

* With the [Tcl command `read`] the content of a file can be read into main
  memory, entirely or partially.

* The [Tcl command `gets`] is for processing of a file "line by line".

.N.center[
A Demonstration will be given live.
]

---
template: plain
name: basic_string_processing
header: ### Basic String Processing

[Tcl command `string`]: https://www.tcl.tk/man/tcl8.4/TclCmd/string.htm

* The [Tcl command `string`] provides various sub-commands for typical string
  operations.

.N.center[
A Demonstration will be given live.
]

---
template: plain
name: selecting_parts_of_reports
header: ### Selecting Parts of Reports

[Tcl command `split`]: https://www.tcl.tk/man/tcl8.4/TclCmd/split.htm
[Tcl command `lindex`]: https://www.tcl.tk/man/tcl8.4/TclCmd/lindex.htm
[Tcl command `foreach`]: https://www.tcl.tk/man/tcl8.4/TclCmd/foreach.htm
[Tcl command `join`]: https://www.tcl.tk/man/tcl8.4/TclCmd/join.htm

* The [Tcl command `split`] is useful to create a list from a (long) string
  with a specific used for separation logical parts.

.N.center[
Such "long strings" may consists of be all the lines of a file that was read
in its entirety, separated by "`\n`".
]

* The [Tcl command `lindex`] provides access to a single element of a list.

* The [Tcl command `foreach`] runs a loop over all elements of a list.

* The [Tcl command `join`] turns elements of a list into a (long) string (i.e.
  it can undo what `split` did).

.N.center[
A Demonstration will be given live.
]

---
template: plain
name: parsing_with_regular_expressions
header: ### Working with Regular Expressions

[Tcl command `regexp`]: https://www.tcl.tk/man/tcl8.4/TclCmd/regexp.htm
[Tcl command `regsub`]: https://www.tcl.tk/man/tcl8.4/TclCmd/regsub.htm

* The [Tcl command `regexp`] compares a string based on a regular expression,
  potentially also parsing-out selected parts.

* The [Tcl command `regsub`] carries out systematic substitutions in a string,
  based on a regular expression.

.N.center[
A Demonstration will be given live.
]

---
template: plain
name: automating_variations
header: ## Automating Variations

Often it is not clear in advance which of several optimizations will have the
best effect or offer the best trade-off between competing goals.

* With Tcl Scripting systematic combinations may be easily tried.

* The resulting script may run in the background or over the night.

---
template: plain
name: general_approach
header: ### General Approach

To automate variations the general approach should be:

* Package what needs to be done in a sub-routine.

* Via parameters specify those parts of the contained commands for which
  different values should be tried systematically.

* Determine the set of actual values the parameters should take.

.N.center[
Note that the following pages outline the approach rather "schematically" than
with concrete Vivado commands.
]

The reason is that this technique as such is very general and this should not be
obscured by using a too specific examples.

---
template: plain
name: find_commonalities
header: #### Find Commonalities

Assume from two GUI sessions journals are extracted, with some differences but
also many obvious commonalities:

.pull-left[
```
proc separate_flow_1 {} {
    = abc def G xyz
    = abc def z
    = abc H ijk
    = qqq G H z
}
```
]
.pull-right[
```
proc separate_flow_2 {} {
    = abc def U xyz
    = abc def z
    = abc V ijk
    = qqq U V z
}
```
]

(To help spotting the commonalities, they are shown in lower case above.)

.N.center[
Of course, commonalities are not always that easy to recognize.._[]
]

.F[:
It may e.g. also be the case that some the differences require additional
commands, to be left out n other cases … what can be easily handled with the
[Tcl command `if`].
]

[Tcl command `if`]: https://www.tcl.tk/man/tcl8.4/TclCmd/if.htm

---
template: plain
name: parametrize_variations
header: #### Parametrize Variations

Factoring-out the commonalities leads to:
```
proc parametrized_flow {arg1 arg2} {
    = abc def $arg1 xyz
    = abc def z
    = abc $arg1 ijk
    = qqq $arg1 $arg2 z
}
```

.pull-left[
The effect of `separate_flow_1` can be produced with:
```
parametrized_flow G H
```
]
.pull-right[
The effect of `separate_flow_2` can be produced with:
```
parametrized_flow U V
```
]

---
template: plain
name: define_argument_sets
header: #### Define Argument Sets

Further analysing what may determine that valid argument sets are:

* `arg1` could take the values `G`, `H`, and `I`, while

* `arg2` could take the values `U`, `V`, `W`, `X`, and `Y`.

These could be represented as two lists:

```
set argset_1 [list G H I]
set argset_2 [list U V W X Y]
```

---
template: plain
name: orthogonal_combination
header: #### Orthogonal Combination

All (orthogonally) possible variations may now be generated with:
```
foreach x $argset_1 {
    foreach y $argset_2 {
        parametrized_flow $x $y
    }
}
```

---
template: plain
name: tree_based_combination
header: #### Tree-Based Combination

Alternatively it may be the case that not all possible combinations make
sense, only the following:

* `G` may be combined with `U`, `V`, `W`
* `H` may be combined with `U` and `X`
* `I` may be combined with `W`, `X`, and `Y`.

This may be specified in a nested-list style as follows …
```
set argset_tree {G {U V W    }
                 H {U     X  }
                 I {    W X Y}
                }
```

… to be used with the following processing loop:
```
foreach {x1 args2} $argset_tree {
    foreach x2 $args2 {
        parametrized_flow $x1 $x2
    }
}
```

---
template: plain
name: tcl_reusability
header: ## Tcl from the Reusability Viewpoint

------------------------------------------------------------------------------

* [Moving Stuff to Subroutines](#moving_stuff_to_subroutines)

* [Sharing Subroutines via Files](#sharing_subroutines_via_files)

* [Auto-Loading Subroutines](#autoloading_subroutines)

* Optional: [The Package Facility](#the_package_facility)

* Optional: [The XILINX Tcl Store](#the_xilinx_tcl_store)

------------------------------------------------------------------------------

---
template: plain
name: moving_stuff_to_subroutines
header: ### Moving Stuff to Subroutines

Structuring programs into subroutines usually makes sense anyway, but
often one special motivation is to increase the potential for reuse.

Tcl has a number of ways to organize subroutines for re-use, which get a
cursory review on the next pages.

.N.center[
Feel free to ask the trainer for live demonstrations.
]

---
template: plain
name: sharing_subroutines_via_files
header: ### Sharing Subroutines via Files

As long as a collection of subroutines occasionally or frequently used
is small, they can be put into an initialisation file which Vivado
reads on startup (= *Startup Script*).

Alternatively each subroutine or groups of subroutines may

* be put into a file of their own

* to be included in the Startup-Script with the [Tcl command `source`].

[Tcl command `source`]: https://www.tcl.tk/man/tcl8.4/TclCmd/source.htm

---
template: plain
name: autoloading_subroutines
header: ### Autoloading Subroutines

If – with time – the *Library of Subroutines* grows, it may be time to
consider using Tcl's feature for *Auto-Loading*.

Basically it requires two simple steps:

* In any directory storing files with common subroutine definitions create
  an *Index File* with the [Tcl command `auto_mkindex`].

* Add the path to these directories to the [Tcl Global Variable `auto_path`].._[]

[Tcl Global Variable `auto_path`]: https://www.tcl.tk/man/tcl8.4/TclCmd/library.htm#M24
[Tcl command `auto_mkindex`]: https://www.tcl.tk/man/tcl8.4/TclCmd/library.htm#M9

.F[:
This then is the only necessary change to the Tcl initialization
file processed by Vivado on Start-Up.
]

---
template: plain
name: the_package_facility
header: ### The Package Facility

[Tcl command `package`]: https://www.tcl.tk/man/tcl8.4/TclCmd/package.htm

The [Tcl command `package`] requires only little more effort to manage libraries
with re-usable subroutines.

.N[
Its main advantage is the option to keep different version of subroutines
available at the same time and let the client code choose which version it
requires.
]

---
template: plain
name: the_xilinx_tcl_store
header: ### The XILINX Tcl Store

The [XILINX Tcl Store] is public repository made available for Vivado Users to
share Tcl extensions with each other.

* Uploaded Tcl packages need to
  [follow specific rules and conventions](https://github.com/Xilinx/XilinxTclStore/wiki/Adding-a-New-App-to-the-Repository#how-to-contribute-a-new-app)
  and

* can then be installed into Vivado by means of a few mouse clicks.

[Xilinx Tcl Store]: https://www.xilinx.com/products/design-tools/vivado/Tcl-store.html


</textarea>
<!-- :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: -->
<!-- ::::::::::::::::::::: )-: ereh TNETNOCLAER fo dne :::::::::::::::::::: -->
<!-- :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: -->
    <script src="remark.min.js" type="text/javascript">
    </script>
    <script type="text/javascript">
      var slideshow = remark.create({ highlightLanguage: 'tcl', highlightStyle: 'docco' });
    </script>
  </body>
</html>
