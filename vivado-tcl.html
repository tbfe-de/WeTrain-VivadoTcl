<!DOCTYPE html>
<html>
  <head>
    <title>Vivado Advanced Tcl Scripting</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <!-- when changing the stylesheet file please see also remark below -->
    <link rel="stylesheet" type="text/css" href="styling.css" />
  </head>
  <body>
<!-- :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: -->
<!-- :::::::::: template pages come first ... skip to REALCONTENT ::::::::: -->
<!-- :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: -->
<textarea id="source">

layout: true
name: blank
styling: styling.css
styling-by: Martin Weitzel

<!--
  *****************************************************************************
  Template used for title page (only)
  *****************************************************************************
  Please change the 'styling-by:' attribute if you change the style-sheet.
-->

.stylehint[
Styled with [{{styling}}]({{styling}}) by {{styling-by}}
]

---
layout: true
name: plain
copyright: (CC) BY-SA
branding:  [Dipl.-Ing. Martin Weitzel](http://tbfe.de) &#8199;&#8199; 2016-04-26 … 2016-04-28
customer:  [PLC2 – Programmable Logic Competence Center](http://plc2.com)

<!--
  *****************************************************************************
  Template used for for pages NOT referring to any Info-Graphic
  *****************************************************************************
  The following attributes are mandatory FOR THE TEMPLATE PAGE and should
  simply be left empty if not meaningful.

  copyright: will be reproduced in each page footer first
  branding: will reproduced in each page footer next
  customer: will be reproduced in each page footer last

  As the above attributes are part of several page templates a global replace
  should be used for consistent changes.

  On pages USING THIS TEMPLATE the following attributes must be set:

  header: ## and header text (i.e. including the markdown formatting indicator)

-->

{{header}}

.pagefooter[
{{copyright}}: {{branding}} .plc2-logo[{{customer}}]
]

---
layout: true
name: linkinfo
copyright: (CC) BY-SA
branding:  [Dipl.-Ing. Martin Weitzel](http://tbfe.de) &#8199;&#8199; 2016-04-26 … 2016-04-28
customer:  [PLC2 – Programmable Logic Competence Center](http://plc2.com)

<!--
  *****************************************************************************
  Template used for for pages INTRODUCING to a new Info-Graphic
  *****************************************************************************
  On this kind of pages a size-reduced version of the whole info graphic will
  be reproduced and occupies approximately 2/3 of the page width. So only add
  little information, preferably links to later pages dealing with single
  sections of the info graphic.

  On pages USING THIS TEMPLATE the following attributes must be set:

  graphic: file path to of the infographic EXCLUDING the suffix.
  header: ## and header text (i.e. including the markdown formatting indicator)

-->

{{header}}

.infographic[
[![Info-Grafik](InfoGraphics/{{graphic}}.png)](InfoGraphics/{{graphic}}.png
                "Click to open – add [CTRL+] SHIFT for new [tabbed] window")
]

.pagefooter[
{{copyright}}: {{branding}} {{customer}} .plc2-logo[]
]

---
layout: false
template: blank
name: frontmatter

.title[
	Advanced Vivado-Scripting._[]
]

.subtitle[
	Controlling the Vivado Design Tool with Tcl-Scripts  
]
.author.pull-left[
	Durchführung  
	Dipl.-Ing. Martin Weitzel  
	Technische Beratung für EDV  
	http://tbfe.de  

]
.client.pull-right[
	Open Training and Workshop  
	2016-04-26 to 2016-04-28  
	Programming Logic Competence Center  
	http://plc2.com
]

.F[:
You may download this presentation from the
[Author's Internet Site](http://tbfe.de/archive)
for any use in compliance with the
[Creative Commons BY-SA License](http://creativecommons.org/licenses/by-sa/2.0/).
As it has been created using the free HTML4-Tool [Remark](http://remarkjs.com),
its content is written using the
[Markdown-Syntax](http://daringfireball.net/projects/markdown/syntax),
so you may even enhance the purely electronic (non-printed) form with your own
annotations, only by means of any ordinary text editor. Just hit the P-key while
viewing this in an internet browser, and follow instructions.
]

???

(use +/- above to adjust the font size for convenient reading)

Remark allows to add presenter notes to each page. As that feature is **not**
used by the author of that presentation, it is available for private annotations
from [this page](#content) on.

Assuming you have downloaded and stored this presentation as HTML-file, proceed
as follows:

* Open the file in a text editor of your choice.

* Locate the page which you want to annotate.

  * You may do so by just scrolling down (but often it is easier to)
  * use the text search feature of your editor.

* Locate the separator to the next page (i.e. `---` in a line of its own).

* Before that add another line with three question marks (`???`) only.

Between these to separator lines you can put your annotations and view these
by using as you just view this page.

**Hint:**
Indent code examples with four spaces at the beginning of each line and they
will be displayed with their original line breaks. As an example, below the
page structure including annotations is shown:

    template: plain
    name: used_for_internal_links
    header: ## Shown at the Top of the Page

    Simply scroll down through this document loaded in an editor and you will
    probably catch the basics of Markdown-Syntax easily, e.g.  how to put in
    *slight* or **strong** emphasis or [add a link](http://tbfe.de/downloads).

    ???
    From here follow the [Presenter Notes], i.e. your private annotations
    ...
    ...

    [Presenter Notes]: adding-longer-links-that-keeps-text--uncluttered

    ...
    up to here.
    ---

To return to the normal view, now press the P-key once more.

<!--
If you want to put in meta-annotations, i.e. text that is not even shown
after pressing the P-key, simply use HTML comments, like it is done here.
-->

---
template: plain
class: agenda
name: content
header: ## Agenda

------------------------------------------------------------------------------

* 2017-04-19

    * Part 1: [Tcl Quick Refresher](#tcl_quick_refresher)

    * Part 2: [Retrieving Scripts from Journals](#retrieving_scripts_from_journals)


* 2017-04-20 

    * Part 3: [Tcl Vivado Integration](#tcl_vivado_integration)

    * Part 4: [Processing Files and Reports](#processing_files_and_reports)

* 2017-04-21

    * Part 5: [Automating Systematic Variations](#automating_variations)

    * Part 6: [Tcl from the Reusablity Viewpoint](#tcl_reusability)

* Optional Extras

    * [Your Choice (maybe some Tk?)](#maybe_some_tk)

------------------------------------------------------------------------------

Each part consists of some "theory" or background information and is enhanced
by practical demonstrations, followed by a work-shop style phase to be used for
solving practical problems, which **YOU** are welcome to contribute.

---
template: plain
name: tcl_quick_refresher
header: ## Part 1: Tcl Quick Refresher

------------------------------------------------------------------------------

* [Tcl Quick Syntax Refresher](#tcl_quick_syntax)

    * [Command and Word Separation](#tcl_command_and_word_sep)
    * [Three Kinds of Quoting](#tcl_three_kinds_of_quoting)
    * [Variable and Command Substitution](#tcl_variable_and_command_subst)
    * [Basic Flow Control](#tcl_basic_flow_control)
    * [List Handling](#tcl_list_handling)
    * [Arithmetic Expressions](#tcl_math_operations)

------------------------------------------------------------------------------

* [Tcl Quick Library Refresher](#tcl_quick_library)

    * [Character Strings](#tcl_character_strings)
    * [Regular Expressions](#tcl_regular_expressions)
    * [File Handling](#tcl_file_handling)
    * [Date & Time](#tcl_date_and_time)

------------------------------------------------------------------------------

---
template: linkinfo
graphic: VivadoVsTclSyntax
name: tcl_quick_syntax
header: ### Tcl Quick Syntax Refresher

* Tcl syntax very simple

* Flexibility comes from

   * using variables and

   * command return values

* Anything else is inside the commands, i.e.

   * uniformity comes from conventions

   * *Tcl Style* and *Vivado Style* slightly differs

---
template: plain
name: tcl_command_and_word_sep
header: #### Command and Word Separation

The first step._[] of *Tcl Syntax Analysis* is locating

* Command Separators:

    * Un-masked Line-Endings

    * Semicolons

* Word Separators:

    * Sequences of *White-Space*

.N[
Command and Word Separation may be protected by any of Tcl's mechanisms
for Quoting.
]

* [Quick-Tcl → Line Concatenation](quick-tcl.html#line_concatenation)
* [Quick-Tcl → Command Separation](quick-tcl.html#command_separation)
* [Quick-Tcl → Word Separation](quick-tcl.html#word_separation)

.F[:
Technically detecting masked line-endings, though it appears to be a kind of
quoting, is a step that occurs separately before Tcl looks for command an
word separators.  A line-ending is masked with a back-slash (`\`), removing
it completely together with any leading white-space of the next line (which
may or may not have another masked line-ending itself).
]

---
template: plain
name: tcl_variable_and_command_subst
header: #### Variable and Command Substitution

---
template: plain
name: tcl_three_kinds_of_quoting
header: #### Three Kinds of Quoting

Tcl Syntax elements triggering special mechanisms can be disabled by
*Quoting* which comes in three forms:._[]

* *Backslash-Quoting* (`\`…) – disable special interpretation of the
  character following next

* *Partial Quoting* (`"` … `"`) – disable word/command separators  
  (backslash quoting still works, full quoting is disabled too)

* *Full Quoting* (`{` … `}`) – disable every special meaning, only …
    * … **match** the closing brace by counting contained braces  
      (opening = +1, closing = -1, closing for counter zero is match)
    * … **disable** counting for braces preceded with a backslash

.N.center[
Mastering the "Tcl-Syntax" to a large degree is to master quoting.
]

* [Quick-Tcl → Quoting with Backslashes](quick-tcl.html#backslash_quoting)
* [Quick-Tcl → Quoting with Double Quotes](quick-tcl.html#doublequote_quoting)
* [Quick-Tcl → Quoting with Curly Braces](quick-tcl.html#curlybrace_quoting)

.F[:
By use of a backslash also certain non-graphic character my be specified,
much like in C/C++.
]

---
template: plain
name: tcl_basic_flow_control
header: #### Basic Flow Control

Flow Control in Tcl is actually implemented via commands:

* It might appear to be part of the syntax – **but is not**

* Instead there is an ordinary parsing of the command line …

    * … which might turn out to call a flow control command

    * … that *internally* implements the required behaviour

.N[
This may not be obvious at first glance, even not at second or third …._[]
]

.F[:
One of the reasons is the use of curly braces as nestable quoting mechanism.
This makes flow control in Tcl look much like (inseparable) blocks of code
in C/C++, though in that case braces are a **syntactical** mechanism.  
In other words: Considering its syntax (only), Tcl knows **a lot less**
– actually close to nothing – about control flow in a program
in comparison to most
any other programming language.
On the other hand this allows to introduce
new ways of flow control simply by defining another command with the desired
behaviour.
]

* [Quick Tcl → Flow Control](quick-tcl.html#flow_control)
* [Quick Tcl → Subroutines](quick-tcl.html#subroutines)

---
template: plain
name: tcl_list_handling
header: #### List Handling

Some commands central to Vivado return there result as lists

* Familiarity with Tcl's list handling is crucial for Vivado scripting too

* Compared to (native) Tcl lists in Vivado are slightly extended

* It may pay to get some experience with lists **outside** Vivado first

.N[
Vivado extensions to Tcl lists have little effect on most any of Tcl's
list handling commands, except when new elements are added to a list.._[]
]

* [Quick Tcl → Lists 101 – The Basics](quick-tcl.html#the_basics)
* [Quick Tcl → Lists 101 – Nested Lists](quick-tcl.html#nested_lists)
* [Quick Tcl → Lists 101 – Constructing Lists](quick-tcl.html#constructing_lists)
* [Quick Tcl → Lists 101 – Extending (and Shorting) Lists](quick-tcl.html#extending_lists)

.F[:
**That is the difference:** In Tcl data is not really "typed". Especially
everything that can be put as element into a list has a representation as
string. Therefore a (native Tcl) list can be "heterogeneous" with respect
to the contained elements. Contrary, in Vivado, when a lists contains
elements that represent specific elements of the *Internal Design Model*,
it must be homogeneous. Accessing a single list element keeps it type
(as some object of the design model), **but using it in a string context
strips away anything and keeps (as string value) just the *name* property.
]

---
template: plain
name: tcl_math_operations
header: #### Mathematical Operations

As a major difference to other high-level programming languages the
Tcl Syntax does **not** know about

* Basic arithmetic, logic, and relational expressions

    * plus, minus, multiplies, …

    * equals/unequals, less, less-or-equal, …

    * negate, and, or, shift

* Mathematic Functions

    * classic trigonometric and their inverses

    * powers and logarithms, …

.N.center[
All this operations are carried out (only) by the command `expr`.
]

* [Quick Tcl → Evaluating Arithmetic Expressions](quick-tcl.html#cmd_expr)

---
template: plain
name: tcl_recursive_syntax
header: #### Recursive Syntax

The individual steps of Tcl syntax analysis happen in a given order
which sometimes – but rarely – is not adequate for the problem at hand.

* E.g. spaces as content of a variable are not word separators …

* … because such are looked up **prior** to variable substitution

.N[
The command `eval` helps out here by starting another run through
syntax analysis on its concatenated arguments after the first – the
one that turned out the command to execute is `eval`.
]

* [Quick Tcl → Evaluating Any String As Command](quick-tcl.html#cmd_eval)

---
template: plain
name: tcl_quick_library
header: ### Tcl Quick Library Refresher

The most important *Tcl Library Functions* for Vivado scripting

* [String Handling](#tcl_character_strings)

* [File Handling](#tcl_file_handling)

* [Date & Time](#tcl_date_and_time)

.N[
Tasks in string processing belonging to the category of
*Analyzing and Parsing Content* are often easily solved via
[Regular Expressions](#tcl_regular_expressions).
]

---
template: plain
name: tcl_character_strings
header: #### Character Strings

Most any handling of character strings is done by sub-commands of
the Tcl command `string`:

* Comparisons

* Substring and single character access

* Character classification

* …

.N[
For concatenating two strings held in variables (or one string
from a variable with a fixed part) no special command is necessary.._[]
]

* [Quick Tcl → Handling Character Strings](quick-tcl.html#char_strings)

.F[:
Probably obvious is that … `$greet$name` … produces the concatenated
content of the variables `greet` and `name`.
Not quite obvious may be how a single letter could be appended to a
variable content, say for pluralisation. If `x` contains some word to
which a literal `s` must be appended, `$xs` clearly doesn't work. The
solution is to use `${x}s`.
]

---
template: plain
name: tcl_regular_expressions
header: #### Regular Expressions

Originating in the Unix tradition, Tcl **of course** supports REs._[] for:

* Flexible comparisons, e.g.

    * … `regexp {[+-][0-9]+([.][0-9]*)?} $num` …

* Parsing, e.g.

   * `regexp {(\d{1,3}(?:\.\d{3})*),(\d{2}) Euro} $ec - euro cent`

* Substitutions, e.g.

    * `regsub {^[ \t]*(.*[^ \t])[ \t]*$) $line {\1} line`

.N.center[
Clearly, the above is does not strive to introduce REs from ground-up :-).
]

* [Quick Tcl → Using Regular Expressions](quick-tcl.html#regular_expressions)

.F[:
Regular Expressions – or REs in short – are part of nearly any modern
programming language. They are rooted in Unix, which used REs since its
very beginning in the `ed` editor, from which later the command `grep`
was derived, as Unix users often started the editor to use the (single)
command `g/`*`re`*`/p` to search in a file for a line matching the pattern
*`re`*.
]

---
template: plain
name: tcl_file_handling
header: #### File Handling

File handling is part of Tcl in two forms:

* Handling files and directories as whole. with

   * most operations as `file` subcommands._[]

* Handling the **content** a files with a C-style API._[]

   * `open` returns a "magic cookie" (called *channel*) …

   * … serving as handle for other commands (`read`, `puts` …) …
 
   * … which must finally be `close`-d

.N[
TCP/IP connections are handled in a much similar style but have to
be opened with the `socket` command.
]

* [Quick Tcl → File Handling](quick-tcl.html#file_handling)

.F[:
Because of tradition (and then backward compatibility) there are some few
more commands, like `pwd`, `cd`, and `glob`. These are also covered under
the *Quick Tcl* Link above.
]


---
template: plain
name: tcl_date_and_time
header: #### Date & Time

In the Unix tradition the Tcl's idea of time is kept as a count since
some epoch.

* Subcommands of `clock` support a rich variety of operations

* Older versions of Tcl counted in seconds from 1970-01-01 GMT

* Resolution now is increased, epoch can be easily determined with

    * `puts [clock format 0]`

.N[
Note that the above displays the epoch in **local time** according to
the time zone of the computer on which the command is executed.._[]
]

* [Quick Tcl → Date And Time](quick-tcl.html#date_and_time)

.F[:
Therefore in Germany the output will probably not be … `00:00:00` … but
… `01:00:00` … (as the time-point of the epoch). So you may want to add
`-timezone UTC` to the above.
]

---

template: plain
name: retrieving_scripts_from_journals
header: ## Retrieving Scripts from Journals

------------------------------------------------------------------------------
* [Accessing the Vivado Design Suite](#accessing_the_vivado_design_suite]

  * [Using the Vivado GUI](#using_the_vivado_gui)
  * [Using Vivado Tcl Commands](#using_vivado_tcl_commands)
------------------------------------------------------------------------------
* [Accessing the Tool Command Language](#accessing_the_tool_command_language)

  * [The Vivado Tcl-Console](#the_vivado_tcl_console)
  * [Suspending the Vivado GUI](#suspending_the_vivado_gui)
  * [Vivado Batch Script Mode](#vivado_batch_script_mode)
------------------------------------------------------------------------------
* [From Journal-Files to Automation](#from_journal_files_to_automation)

  * [Turning Journals into Tcl-Scripts](#turning_journals_into_tcl_scripts)
  * [Plain Use vs. Packaging in `proc`s](#plain_use_vs_packaging_in_procs)
------------------------------------------------------------------------------
* [Bring-in Your Own Design?](#bring_in_your_own_design)

---
template: linkinfo
graphic: Tcl_Vivado_Integration
name: accessing_the_vivado_design_suite
header: ## Accessing the Vivado Design Suite

There are two major ways to work with Vivado:

* [Via GUI](#using_the_vivado_gui)

* [Via Tcl Commands](#using_vivado_tcl_commands)

The GUI is usually brought up first when Vivado is started

* by clicking on its icon or
* by specifying the path to its executable on the command line.._[]

.F[:
At the command line the option `-mode tcl` or `-mode batch` may be used which
would not show the GUI immediately but only when requested.
]

---
template: plain
name: using_the_vivado_gui
header: ### Using the Vivado GUI

For many first-time users Vivado may appear to be a GUI based tool, accessed
in well-known ways:

* Present *State Information* in various "Graphical Views", which the user can
  open and close, resize and arrange on the screen.

* *Initiate Actions* by choosing from *Menus* or pressing *Buttons* provided
  in a Toolbars …

* … eventually prompting for action-specific details in *Pop-Up Dialogues*.

.N.center[
Participants of this training are assumed to be more or less familiar  
with using Vivado via the GUI.
]

---
template: plain
name: using_vivado_tcl_commands
header: ### Using Vivado Tcl Commands

Besides preparing and elaborating a Design Model via the Vivado GUI there is
also a Programming Language Interface.

.N.center[
Using Vivado via that interface is at the center of this training.
]

Though in general everything that can be achieved via the Programming Language
Interface can also be achieved via the GUI (and vice versa._[]), some deeper
knowledge of the former will pay for

* automating systematic and repeated tasks,

* including decisions what to do next.

.F[:
Though, some specific tasks may be easier in one of the two ways, and also both
approaches may intersect by assigning a sequence of Tcl commands to a GUI menu
or button.
]

---
template: plain
name: accessing_the_tool_command_language
header: ### Accessing the Tool Command Language

Technically most of the Vivado GUI is

* just an interface to an underlying data base – called the *Design Model*
* which can also be accessed – i.e. inspected and modified – via a
  *Command Language*.

More precisely, *Tcl* once developed by John Ousterhout in the mid 90s, has
been chosen as *Tool Command Language* for Vivado.

.pull-left[
Tcl is known for its
* terse,
* minimal,
* "shell"-like syntax …._[]
]
.pull-right[
… and providing core features like
* variables and data structures,
* sub-routines and flow-control,
* access to OS-services etc.
]

As a **Tool Command Language for Vivado** *Tcl* is extended with many new
commands and application specific internal data types.

.F[:
Compared more recent language developments Tcl's syntax may sometimes surprise
rather by simplicity than by complexity but with its straight forward approach
it lends itself very good for the job. The rich command set added by Vivado is
recognizably modelled following a slightly different "style" than the native
Tcl commands, which has its pro's and con's.
]

---
template: plain
name: the_vivado_tcl_console
header: ### The Vivado Tcl Console

The Vivado GUI makes a *Tcl Console* available which can be used to

* **find the equivalent Tcl command(s)** for actions invoked via the GUI, like
  * preparing the design model,
  * running synthesis or implementation,
  * generating reports, or
      * for viewing or
      * modifying design objects
  * as part of design elaboration,
  * writing bitstream-files, or just
* execute any Tcl command from Vivado.

.N[
Watching the command equivalent for GUI actions in the Tcl console is an
extremely useful approach._[] if you want to find out which commands are
necessary to automate a systematic task.
]

.F[:
Besides
[Extracting Tcl Commands from a Journal](#from_journal_files_to_automation)
as is discussed later.
]

---
template: plain
name: suspending_the_vivado_gui
header: ### Suspending the Vivado GUI

After starting the Vivado GUI – which is the default when running by clicking on
the icon or starting it from a *ix or Windows Shell …

.pull-left[
… entering the Tcl command
```
stop_gui
```

will temporarily suspend the GUI and place Vivado in *Tcl Mode* …
]
.pull-right[
… i.e. now you work with a raw *Tcl Shell*, from which the command

```
start_gui
```

returns to the Vivado GUI.
]

In *Tcl Mode* you have all the commands available that you may use at the
command line of the *Tcl Console* in the Vivado GUI.

.N[
In most cases you will probably prefer the Vivado GUI, as it also has command
completion and colorizing, two features helpful for novices to get the Tcl
syntax right.
]

---
template: plain
name: vivado_batch_script_mode
header: ### Vivado Batch Script Mode

If the only thing to run in a Vivado session is a script with (prepared) Tcl
commands, another option is to use *Tcl Batch Script Mode*.

The following will just run `my_script.tcl`:._[]
```
vivado -mode batch -source my_script.tcl
```

It is equivalent to running Vivado in in *Tcl Mode* with
```
vivado -mode tcl
```

and then enter
```
source my_script.tcl
```

or to run the as Tcl console command after starting up the Vivado GUI.

.F[:
Assumed here is that Vivado (i.e. the executable program name) is in your
command search path so that the command `vivado` runs the design suite.
]

---
template: plain
name: from_journal_files_to_automation
header: ### Form Journal Files to Automation

To get an initial Tcl script for work-flow to automate, it is often easiest to

* start an interactive (GUI) Vivado session,

* run the typical (exemplary) steps by using GUI controls,

* extract the Tcl commands actually run from the Journal File.._[]

.N[
The standard location where Vivado stores Journals (and Log-Files too) is
usually in some way related to your "Home" directory.
]

If you have no idea where the files might be located, try a search for

* `vivado*.jou` or
* `vivado*.log`

where files with a numeric part in their name are usually backups from older
sessions and files without are from the most recent one.

.F[:
In principle the commands could also be extracted from the Log-File. But the
latter is much more cluttered with additional information, which might only
sometimes be useful. (E.g. if you did not run a particularly "clean" sequence
of the commands you wanted to automate, but had a "long and winding" session
from which you want to extract "just a few parts of special interest".
]

---
template: plain
name: turning_journals_into_tcl_scripts
header: #### Turning Journals into Tcl-Scripts

Turning a Journal into a (first version) of a Tcl command sequence stored in
a file, can be as easy as to

* remove the heading comments (all lines starting with `#`), then

* remove the first command-line containing `start_gui`

.N[
Instead of removing the heading comments completely, you may rather decide to
change it into something meaningful._[]
]

To provide some structure, you may also want to:

* Insert blank lines between groups of logically related commands.

* Add comments to commands (or command groups) of special interest.

.F[:
In other words: the point is to get rid of any content which is useless or even
misleading to those who later look at the file and want to find out what it does
and how its achieves important intermediate goals.
]

---
template: plain
name: journal_to_tcl_scripts_example_1
header: ##### Example for Turning Journal into Tcl-Script (1)

Beginning of original journal:
```
#-----------------------------------------------------------
# Vivado v2016.4 (64-bit)
# SW Build 1756540 on Mon Jan 23 19:11:19 MST 2017
# IP Build 1755317 on Mon Jan 23 20:30:07 MST 2017
# Start of session at: Sun Apr  9 16:41:38 2017
# Process ID: 8490
# Current directory: /home/martin
# Command line: vivado
# Log file: /home/martin/vivado.log
# Journal file: /home/martin/vivado.jou
#-----------------------------------------------------------
start_gui
open_project /home/martin/project_1/project_1.xpr
reset_run synth_1
…
```

---
template: plain
name: journal_to_tcl_scripts_example_2
header: ##### Example for Turning Journal into Tcl-Script (2)

Parts kept as Tcl-command sequence:
```
open_project /home/martin/project_1/project_1.xpr
reset_run synth_1
launch_runs synth_1 -jobs 2
wait_on_run synth_1
open_run synth_1 -name synth_1
launch_runs impl_1 -jobs 2
wait_on_run impl_1
close_design
open_run impl_1
open_run synth_1 -name synth_1
report_timing_summary -delay_type min_max -report_unconstraineds
 -check_timing_verbose -max_paths 10 -input_pins -name timing_1
set_property STEPS.WRITE_BITSTREAM.ARGS.RAW_BITFILE true
 [get_runs impl_1]
launch_runs impl_1 -to_step write_bitstream -jobs 2
wait_on_run impl_1
```

.N.center[
Lines shown indented by one space above actually form  
**one single (long) line** in the Tcl-command script.
]

---
template: plain
name: journal_to_tcl_scripts_example_2
header: ##### Example for Turning Journal into Tcl-Script (3)

Tcl script with some parts removed and re-formatted for readability:._[]

```
# project to work with (has been created manually before)
#
open_project /home/martin/project_1/project_1.xpr

# run synthesis and implementation (as separate steps)
#
launch_runs synth_1 -jobs 2
wait_on_run synth_1
launch_runs impl_1 -jobs 2
wait_on_run impl_1

# create a bitstream file as "raw" bitfile
#
set_property\
    STEPS.WRITE_BITSTREAM.ARGS.RAW_BITFILE true\
    [get_runs impl_1]
launch_runs impl_1 -to_step write_bitstream -jobs 2
wait_on_run impl_1
```

.F[:
For the moment, do not waste too many thoughts on the exact the content of the
example: it is only meant to demonstrate that the Tcl commands extracted from
the journal may not be used as found – "1:1" – but in a modified form.
]

---
template: plain
name: plain_use_vs_packaging_in_procs
header: ### Plain Use vs. Packaging in `proc`s

When you finally have extracted the Tcl commands to be executed (maybe
augmented by comments), there are two options:._[]

* Just provide the command sequence in a file.

* In addition wrap the command sequence in a Tcl `proc`.

.pull-left[
```
# my fine design
# (non-project mode)
read_vhdl …
read_xdc …
…
synth_design …
opt_design …
…
write_bitstream …
```
]
.pull-right[
```
proc my_fine_design {} {
    read_vhdl …
    read_xdc …
    …
    synth_design …
    opt_design …
    …
    write_bitstream …
}
```
]

The second approach adds only little overhead but lends itself much
better to later refinements. 

.F[:
In the first case, when the file is `source`-d, the commands are immediately
executed.  In the second case only the subroutine `my_fine_design` is defined
which then needs to be explicitly executed like any ordinary Tcl command.
]

---
template: plain
name: bring_in_your_own_design
header: ### Bring-in Your Own Design?

Up to this point, Vivado's Example Projects has been used, mostly as they are
easily accessible.

.N.center[
Feel free to bring-in your own design – or parts of it.
]

As long as missing Tcl-knowledge is the gap to fill, the trainer will be happy
to answer any questions based on a design you brought-in, or on examples you
created yourself during the next days.

.W[
Make sure you do not accidentally disclose parts of your work your employer
might want to be kept secret, as for technical and formal reasons it would be
difficult to get a legally binding NDA between you, the trainer and all
participants.
]

---
template: plain
name: tcl_vivado_integration
header: ## Tcl Vivado Integration

------------------------------------------------------------------------------
* [Tcl and Vivado – The Big Picture](#tcl_vivado_big_picture)

    * [Non-Project- vs. Project Mode](#nonproject_vs_project_mode)
    * [Understanding Project Mode](#understanding_project_mode)
    * [Interaction of Design Model and Tcl](#design_model_and_tcl)
------------------------------------------------------------------------------
* [Vivado Command Conventions](#vivado_command_conventions)

    * [Tcl vs. Vivado Commands](#tcl_vs_vivado_commands)
    * [Necessity of Quoting](#necessity_of_quoting)
    * [Storing Prepared Commands](#storing_prepared_commands)
------------------------------------------------------------------------------
* [Understanding the Design Model](#understanding_the_design_model)

    * [Basics of Design Navigation](#basics_of_design_navigation)
    * [Accessing Object Properties](#accessing_object_properties)
------------------------------------------------------------------------------

---
template: linkinfo
graphic: Tcl_Vivado_Integration
name: tcl_vivado_big_picture
header: ### Tcl and Vivado – The Big Picture

* Being
  **A *Tool Command Language* by Design** …

* … Tcl lends itself perfectly as scripting language for Vivado …

* … though the added commands not always follow conventions and
  style of (native) Tcl

---
template: linkinfo
graphic: VivadoModesAndTcl
name: nonproject_vs_project_mode
header: #### Non-Project vs. Project Mode

* *Non-Project Mode* and *Project Mode* are two ways to use Vivado
  during design elaboration …

* … but the difference is **not** how much of the work is done via
  GUI and how much with Tcl

---
template: plain
name: general_design_activities
header: ##### General Design Activities

From a general viewpoint activities in *Non-Project-* and *Project-Mode* are
the same:

1. Prepare the Design Model
2. Elaborate the Design (maybe minimal on first run through)
3. Synthesize the Design (maybe go back to step 2)
4. Implement the Design (maybe go back to step 2 or 3)
5. Optimize the Design (maybe go back to step 2, 3, or 4)
6. Generate a Bitstream

.N[
Decisions to branch back typically depend on various ways of "proofing._[]"
the design as far as currently elaborated will work according to its
specification on real hardware.
]

.F[:
Note that the term "proof" is used here in a loose and broad meaning: it
may range from visual inspections of reports and simulation run results to half or fully
automated constraint checking that may cause a step to fail, thereby
"blocking the road" to continue.
]

---
template: plain
name: understanding_non_project_mode
header: ##### Representation of the Design Model

.F[:
In principle, the Design Model is just an internal data base representing all
details of a design as interconnected "objects" of various "classes" in kind of
an "in memory data base". The Vivado GUI provides various "views" to inspect
and modify the contained objects in great detail, where modifications ranges
from trivial (e.g. changing a single property of a single object) to extremely
complex (e.g. generate an elaborated design from VHDL or Verilog source files).
As the model is both, *accessible* and *modifiable* via the *Tcl*-commands,
any kind of complex 
]

---
template: plain
name: understanding_non_project_mode
header: #### Understanding Non-Project Mode



---

template: plain
name:
header: ##### Non-Project Mode Tcl Commands (Overview)

TBD

---

template: plain
name: understanding_non_project_mode
header: ##### Tcl Command ...

TBD


---

template: plain
name:
header: ##### Tcl Command ...

TBD


---

template: plain
name: 
header:

TBD


---

template: plain
name: 
header:

TBD


---

template: plain
name: 
header:

TBD

---
template: linkinfo
graphic: VivadoProjectMode
name: understanding_project_mode
header: #### Understanding Project Mode

* Relationships in *Project Mode* need some more explanation

* Basically it automates managing dependencies between files while minimising
  tool use

* Also options for various optimisation runs are specified in a packaged
  form, called *Strategies*

---

template: plain
name:
header: ##### Project Mode Tcl Commands (Overview)

TBD

---

template: plain
name: understanding_non_project_mode
header: ##### Tcl Command ...

TBD


---

template: plain
name:
header: ##### Tcl Command ...

TBD


---

template: plain
name: 
header:

TBD


---

template: plain
name: 
header:

TBD


---

template: plain
name: 
header:

TBD

---
template: plain
name: vivado_command_conventions
header: ### Vivado Command Conventions

As already has been mentioned Tcl commands

* evaluate their arguments themselves (each)

* hence achieve "uniformity" by following conventions only

* where *Tcl Style* and *Vivado Style* slightly differs

.N.center[
Differences are not quite from separate worlds but visible enough.
]

Therefore it pays to be aware of a command's origin – Tcl or Vivado …._[]

.F[:
… somewhat like being aware whether driving a gear-shifting car or a
car with automatic transmission – Tcl is more on the gear-shifting side,
Vivado more on the other (author's advice and personal opinion).  
The reasons for the differences are manifold and partially speculative:
(1) Tcl itself is not completely "as if made from one piece" and therefore
not quite consistent. (2) There may have been the intent to be more
"user friendly" in Vivado. (3) Scarce resources originally guiding some
Tcl design decisions are no longer an issue today.
]

---
template: linkinfo
graphic: VivadoVsTclSyntax
name: tcl_vs_vivado_commands
header: #### Tcl vs. Vivado Commands

* **Common** to Tcl and Vivado is Syntax Analysis only

* Beyond that slightly different styles become apparent

---
template: linkinfo
graphic: VivadoVsTclSyntax
name: necessity_of_quoting
header: #### Necessity of Quoting

TBD

---
template: plain
name: 
header: #### Quoting Example ...

TBD

---
template: plain
name: 
header: #### Quoting Example ...

TBD

---
template: plain
name: 
header: #### Quoting Example ...

TBD

---
template: plain
name: 
header: #### Quoting Example ...

TBD

---
template: plain
name: 
header: #### Quoting Example ...

TBD

---
template: linkinfo
graphic: VivadoVsTclSyntax
name: storing_prepared_commands
header: #### Storing Commands in Variable

TBD

---
template: plain
name: 
header: ##### Stored Command Example ...

TBD

---
template: plain
name: 
header: ##### Stored Command Example ...

TBD

---
template: plain
name: 
header: ##### Stored Command Example ...

TBD

---
template: plain
name: 
header: ##### Stored Command Example ...

TBD

---
template: plain
name: 
header: ##### Stored Command Example ...

TBD

---
template: plain
name: 
header: ##### Stored Command Example ...

TBD

---
template: plain
name: understanding_the_design_model
header: ### Understanding the Design Model

Prior to navigating._[] within the design using Tcl commands there needs to be a basic
understanding the model itself.

.I[
For more information refer to:  
[XILINX UG894] **Using Tcl Scripting** – for an Introduction  
[XILINX UG835] **Vivado Tcl Commands** – Complete Reference
]

[XILINX UG894]: http://www.xilinx.com/support/documentation/sw_manuals/xilinx2016_4/ug894-vivado-tcl-scripting.pdf
[XILINX UG835]: http://www.xilinx.com/support/documentation/sw_manuals/xilinx2016_4/ug835-vivado-tcl-commands.pdf

.F[:
Navigating the design model is usually the first step to select one or more objects,
which subsequently are accessed or modified.
]

---
template: plain
name: basics_of_design_navigation
header: #### Basics of Design Navigation

Navigating to objects in the design model is similar to navigating to files
in a directory tree.

* There is a *Top Level Object* …

    * (much like the root directory of a file system)

* … which may also be changed

    * (much like the current working directory)

.I[
[XILINX UG894] → **Tcl Scripting in Vivado**  
                → Accessing Design Objects  
                → Getting By Name – Traversing the Design Hierarchy
]

[XILINX UG894]: http://www.xilinx.com/support/documentation/sw_manuals/xilinx2016_4/ug894-vivado-tcl-scripting.pdf

---
template: plain
name: understanding_object_relations
header: #### Understanding Object Relations

Objects are inter-related via connections._[]

*  which may also be used as a base for navigation

* but first the relationships need to be understood

.I[
[XILINX UG894] → **Tcl Scripting in Vivado**  
               → Accessing Design Objects  
               → Getting Objects by Relationship
]

[XILINX UG894]: http://www.xilinx.com/support/documentation/sw_manuals/xilinx2016_4/ug894-vivado-tcl-scripting.pdf
[XILINX UG835]: http://www.xilinx.com/support/documentation/sw_manuals/xilinx2016_4/ug835-vivado-tcl-commands.pdf

.F[:
For basic and even for moderately ambitious tasks it is fully sufficient
to grasp the main relationships while ignoring the details. For the full
picture see: *[XILINX UG835] → Ch. 1: Introduction → First Class Tcl Objects and
Relationships  → Object Relationships*
]

---
template: plain
name: navigating_via_relations
header: #### Navigating via Relations

The general form is this:._[]

* `get_`*`kind`* ` -of_objects ` *`which`*, where

   * *`kind`* depends on the type of objects **to be** looked-up, and

   * *`which`* is the type of objects **from which** the relation originates

.N.center[
**Not all combinations of *`kind`* and *`which`* are valid!**
]

Get accustomed to look-up proper usage in [XILINX UG835] or use the command with
the `-help` option interactively.

[XILINX UG835]: http://www.xilinx.com/support/documentation/sw_manuals/xilinx2016_4/ug835-vivado-tcl-commands.pdf

.F[:
Note that the syntax chosen seems to strive for being readable in natural language:  
`get_pins -of_objects [get_nets -hier]`
]

---
template: plain
name: accessing_object_properties
header: #### Filtering on Selection

Many commands selecting objects have a `-filter` option

* The required syntax deviates somewhat from Tcl style

* Often it makes sense to put the whole selection in curly braces

.N.center[
**Be aware no variable substitution takes place in curly braces.**._[]
]

* [Quick Tcl → Variable (quickly)](quick-tcl.html#variables_quickly)

.F[:
Be aware of backslash substitutions (for `\n`, `\t`, etc.) if you use double
quotes instead and be aware of word (and command) separation if you use no
quoting at all.
]

---
template: plain
name: accessing_object_properties
header: #### Accessing Object Properties

Design objects generally have properties._[]

* Some properties are common to all objects

* Others vary with the type of object

* (also filtering is based on properties)

.I[
For more information see:  
[XILINX UG835] → Ch. 1: Introduction  
               → First Class Tcl Objects and Relationships  
               → Object Properties
]

* [XILINX UG835] → Ch. 3: Tcl Commands Listed Alphabetically →
  * `get_property`
  * `list_property`
  * `report_property`  
  * … (and others) …

.F[:
As this presentation could never be exhaustive without becoming a reference
manual, no attempt into that direction is made at all: get accustomed to
look-up relevant information in [XILINX UG835]. **Now!**
]

[XILINX UG835]: http://www.xilinx.com/support/documentation/sw_manuals/xilinx2016_4/ug835-vivado-tcl-commands.pdf

---
template: linkinfo
graphic: VivadoDesignFlows
name: from_design_model_to_bitstream
header: ### From Design Model to Bitstream

* The typical final goal of any design is the *Bitstream File*

* Before this can happen the design usually needs some elaboration

* (Thorough testing not shown here – though highly to recommend
  before generating and using a bitstream file)


.F[:
Of course there are many reasons why a bitstream file might be never produced.
E.g. a design could turn out to be inappropriate during elaboration or
testing and is completely overturned. Or the goal is to just to test tools
Vivado uses internally. Finally, the bitstream files eventually produced
during this workshop are also not of much interest … (and will probably
never be loaded to a concrete hardware).
]

---
template: plain
name: non_project_mode_outline
header: #### Non-Project Mode Outline

In *Non-Project Mode*

* Files (Verilog/VHDL, Constraints, Simulation) need to explicitly loaded

* Toos (Synthesis, Implementation/Optimizations) need to explicitly run

.I[
For an outline of a session in non-project mode see:  
[XILINX UG888] → Lab 1: Using the Non-Project Design Flow
]

[XILINX UG888]: http://www.xilinx.com/support/documentation/sw_manuals/xilinx2016_4/ug888-vivado-design-flows-overview-tutorial.pdf

---
template: plain
name: project_mode_outline
header: #### Project Mode Outline

In *Project Mode*

* Vivado manages dependencies via *File Sets*

* Arranges automatically for the adequate tools to run

* Provides optimisation via *Strategies*

.I[
For an outline of a session in project mode see:
[XILINX UG888]: → Lab 2: Using the Project Design Flow
]

[XILINX UG888]: http://www.xilinx.com/support/documentation/sw_manuals/xilinx2016_4/ug888-vivado-design-flows-overview-tutorial.pdf

---
template: plain
name: processing_files_and_reports
header: ## Processing Files and Reports

------------------------------------------------------------------------------

* Scanning Directories

* Basic Text File Processing

* Selecting Sections in Reports

* Parsing Reports with Regular Expressions

------------------------------------------------------------------------------

---
template: plain
name: automating_variations
header: ## Automatic Systematic Variations

TBD

---
template: plain
name: general_approach
header: ### General Approach

TBD

---
template: plain
name: find_commonalities
header: #### Find Commonalities

TBD

---
template: plain
name: parametrize_variations
header: #### Parametrize Variations

TBD

---
template: plain
name: define_argument_sets
header: #### Parametrize Variations

TBD

---
template: plain
name: orthogonal_combination
header: #### Orthogonal Combination

TBD

---
template: plain
name: tree_based_combination
header: #### Tree-Based Combination

TBD

---
template: plain
name: tcl_reusability
header: ## Tcl from the Reusability Viewpoint

------------------------------------------------------------------------------

* Example: Moving Useful Stuff to Subroutines

* Example: Sharing Subroutines via Files

* Optional Example: Auto-Loading Files

* Optional Example: The Package Facility

------------------------------------------------------------------------------

---
template: plain
name: maybe_some_tk
header: ## Your Choice (maybe some Tk?)

------------------------------------------------------------------------------

* Example: Remote Tracing and Debugging

* Optional: Overview about Tcl Development Tools

* (Anything else you would find interesting?)

------------------------------------------------------------------------------


</textarea>
<!-- :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: -->
<!-- ::::::::::::::::::::: )-: ereh TNETNOCLAER fo dne :::::::::::::::::::: -->
<!-- :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: -->
    <script src="remark.min.js" type="text/javascript">
    </script>
    <script type="text/javascript">
      var slideshow = remark.create({ highlightLanguage: 'tcl', highlightStyle: 'docco' });
    </script>
  </body>
</html>
